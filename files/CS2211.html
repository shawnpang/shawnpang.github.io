<!DOCTYPE html>
<html class="theme theme-white">
<head>
<meta charset="utf-8">
<title>CS2211</title>
<link href="https://www.zybuluo.com/static/assets/template-theme-white.css" rel="stylesheet" media="screen">
<style type="text/css">

#wmd-preview h1  {
    color: #0077bb; /* 将标题改为蓝色 */
}</style>
</head>
<body class="theme theme-white">
<div id="wmd-preview" class="wmd-preview wmd-preview-full-reader"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="txl1" id="cs2211">CS2211</h1><div class="md-section-divider"></div><h2 data-anchor-id="cc6a" id="cs"><code>CS</code></h2><p data-anchor-id="qg3i"><div class="toc"><div class="toc">
<ul>
<li><a href="#cs2211">CS2211</a><ul>
<li><a href="#cs">CS</a></li>
<li><a href="#1-introducing-c">1. Introducing C</a><ul>
<li><a href="#11-history-of-c">1.1 History of C</a></li>
<li><a href="#12-c-based-languages">1.2 C-Based Languages</a></li>
<li><a href="#13-strengths-and-weaknesses-of-c">1.3 Strengths and Weaknesses of C</a></li>
</ul>
</li>
<li><a href="#2-c-fundamentals">2. C Fundamentals</a><ul>
<li><a href="#21-compiling-and-linking">2.1 Compiling and Linking</a></li>
<li><a href="#22-general-form-of-a-simple-program">2.2 General Form of a Simple Program</a></li>
<li><a href="#23-comments">2.3 Comments</a></li>
<li><a href="#24-variables-and-assignment">2.4 Variables and Assignment</a></li>
<li><a href="#25-defining-names-for-constants">2.5 Defining Names for Constants</a></li>
<li><a href="#26-layout-of-a-c-program">2.6 Layout of a C Program</a></li>
</ul>
</li>
<li><a href="#3-formatted-inputoutput">3. Formatted Input/Output</a></li>
<li><a href="#4-expressions">4. Expressions</a><ul>
<li><a href="#41-introduction">4.1 Introduction</a></li>
</ul>
</li>
<li><a href="#42-operators">4.2 Operators</a></li>
<li><a href="#5-selection-statements">5. Selection Statements</a></li>
<li><a href="#6-loops">6. Loops</a></li>
<li><a href="#7-basic-types">7. Basic Types</a></li>
<li><a href="#8-arrays">8. Arrays</a><ul>
<li><a href="#81-definitions">8.1 Definitions</a></li>
<li><a href="#82-one-dimensional-arrays">8.2 One-Dimensional Arrays</a></li>
<li><a href="#83-multidimensional-arrays">8.3 Multidimensional Arrays</a></li>
<li><a href="#84-variable-length-arrays">8.4 Variable-Length Arrays</a></li>
</ul>
</li>
<li><a href="#9-functions">9. Functions</a><ul>
<li><a href="#91-format">9.1 format</a></li>
<li><a href="#92-arguments">9.2 Arguments</a></li>
<li><a href="#93-the-return-statement">9.3 The return Statement</a></li>
</ul>
</li>
<li><a href="#10-program-organization">10. Program Organization</a><ul>
<li><a href="#101-local-variables">10.1 Local Variables</a></li>
<li><a href="#102-external-variables">10.2 External Variables</a></li>
<li><a href="#103-blocks">10.3 Blocks</a></li>
<li><a href="#104-scope">10.4 Scope</a></li>
<li><a href="#105-organizing-a-c-program">10.5 Organizing a C Program</a></li>
</ul>
</li>
<li><a href="#11-pointers">11. Pointers</a><ul>
<li><a href="#111-pointer-variables">11.1 Pointer Variables</a></li>
<li><a href="#112-the-address-and-indirection-operators">11.2 The Address and Indirection Operators</a></li>
<li><a href="#113-pointer-assignment">11.3 Pointer Assignment</a></li>
<li><a href="#114-pointer-as-arguments">11.4 Pointer as Arguments</a></li>
<li><a href="#115-pointers-as-return-values">11.5 Pointers as Return Values</a></li>
</ul>
</li>
<li><a href="#12-pointers-and-arrays">12. Pointers and Arrays</a></li>
<li><a href="#13-strings">13. Strings</a></li>
<li><a href="#14-the-preprocessor">14. The Preprocessor</a><ul>
<li><a href="#141-how-the-preprocessor-works">14.1 How the Preprocessor Works</a></li>
<li><a href="#142-preprocessing-directives">14.2 Preprocessing Directives</a></li>
<li><a href="#143-macro-definitions">14.3 Macro Definitions</a></li>
<li><a href="#144-conditional-compilation">14.4 Conditional Compilation</a></li>
<li><a href="#145-miscellaneous-directives">14.5 Miscellaneous Directives</a></li>
</ul>
</li>
<li><a href="#15-writing-large-programs">15. Writing Large Programs</a><ul>
<li><a href="#151-source-files">15.1 Source Files</a></li>
<li><a href="#152-header-files">15.2 Header Files</a></li>
<li><a href="#153-divding-a-program-into-files">15.3 Divding a Program into Files</a></li>
<li><a href="#154-building-a-multiple-file-program">15.4 Building a Multiple-File Program</a></li>
</ul>
</li>
<li><a href="#16-structures-unions-and-enumerations">16. Structures, Unions, and Enumerations</a><ul>
<li><a href="#161-structure-variables">16.1 Structure Variables</a></li>
<li><a href="#162-structure-types">16.2 Structure Types</a></li>
<li><a href="#163-nested-arrays-and-structures">16.3 Nested Arrays and Structures</a></li>
<li><a href="#164-unions">16.4 Unions</a></li>
<li><a href="#165-enumerations">16.5 Enumerations</a></li>
</ul>
</li>
<li><a href="#17-advanced-uses-of-pointers">17. Advanced Uses of Pointers</a><ul>
<li><a href="#171-dynamic-storage-allocation">17.1 Dynamic Storage Allocation</a></li>
<li><a href="#172-dynamically-allocated-strings">17.2 Dynamically Allocated Strings</a></li>
<li><a href="#173-dynamically-alloated-arrays">17.3 Dynamically Alloated Arrays</a></li>
<li><a href="#174-deallocating-storage">17.4 Deallocating Storage</a></li>
<li><a href="#175-linked-lists">17.5 Linked Lists</a></li>
<li><a href="#176-pointers-to-pointers">17.6 Pointers to Pointers</a></li>
<li><a href="#177-pointers-to-functions">17.7 Pointers to Functions</a></li>
<li><a href="#178-restricted-pointers">17.8 Restricted Pointers</a></li>
<li><a href="#179-flexible-array-members">17.9 Flexible Array Members</a></li>
</ul>
</li>
<li><a href="#18-declarations">18. Declarations</a><ul>
<li><a href="#181-declaration-syntax">18.1 Declaration Syntax</a></li>
<li><a href="#182-storage-classes">18.2 Storage Classes</a></li>
<li><a href="#183-type-qualifiers">18.3 Type Qualifiers</a></li>
<li><a href="#184-declarators">18.4 Declarators</a></li>
<li><a href="#185-initializers">18.5 Initializers</a></li>
<li><a href="#186-inline-functions">18.6 Inline Functions</a></li>
</ul>
</li>
<li><a href="#19-program-design">19. Program Design</a><ul>
<li><a href="#191-modules">19.1 Modules</a></li>
<li><a href="#192-information-hiding">19.2 Information Hiding</a></li>
<li><a href="#193-abstract-data-types">19.3 Abstract Data Types</a></li>
<li><a href="#194-a-stack-abstract-data-type">19.4 A Stack Abstract Data Type</a></li>
<li><a href="#195-design-issues-for-abstract-data-types">19.5 Design Issues for Abstract Data Types</a></li>
</ul>
</li>
<li><a href="#20-low-level-programming">20. Low-Level Programming</a><ul>
<li><a href="#201-bitwise-operators">20.1 Bitwise Operators</a></li>
<li><a href="#202-bit-fields-in-structures">20.2 Bit-Fields in Structures</a></li>
<li><a href="#203-other-low-level-techniques">20.3 Other Low-Level Techniques</a></li>
</ul>
</li>
<li><a href="#21-the-standard-library">21. The Standard Library</a><ul>
<li><a href="#211-using-the-library">21.1 Using the Library</a></li>
<li><a href="#212-c89-library-overview">21.2 C89 Library Overview</a></li>
<li><a href="#213-c99-library-changes">21.3 C99 Library Changes</a></li>
<li><a href="#214-the-stddefh-header-common-definitions">21.4 The <stddef.h> Header: Common Definitions</stddef.h></a></li>
<li><a href="#215-the-stdboolh-header-c99-boolean-type-and-values">21.5 The <stdbool.h> Header (C99): Boolean Type and Values</stdbool.h></a></li>
</ul>
</li>
<li><a href="#22-inputoutput">22. Input/Output</a><ul>
<li><a href="#221-streams">22.1 Streams</a></li>
<li><a href="#222-file-operations">22.2 File Operations</a></li>
<li><a href="#223-formatted-io">22.3 Formatted I/O</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="bjbl" id="1-introducing-c">1. Introducing C</h2><div class="md-section-divider"></div><h3 data-anchor-id="1gj9" id="11-history-of-c">1.1 History of C</h3><ul data-anchor-id="6leh">
<li>Origins <br>
<ul><li>1969 By-product of UNIX</li>
<li>1973 Assembly &gt; B &gt; New B &gt; C</li></ul></li>
<li>Standardization <br>
<ul><li>1978 The C Programming Language by Brian Kernighan and Dennis Richie</li>
<li>K&amp;R's fussiness</li>
<li>1980s C's Compiler available on other plarforms</li>
<li>1990 International Organization for Standardization (ISO) (C90)</li>
<li>1999 New ISO publication (C99)</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8qir" id="12-c-based-languages">1.2 C-Based Languages</h3><ul data-anchor-id="oaxs">
<li>C++ includes all the features of C, but adds classes and other features to support OOP</li>
<li>Java is based on C++</li>
<li>C# is a more recent language derived from C++ and Java</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="dfiv" id="13-strengths-and-weaknesses-of-c">1.3 Strengths and Weaknesses of C</h3><pre data-anchor-id="9fdn"><code>* Features
    * C is a low-level language
    * C is a small language - less features but more libraries
    * C is a permissive language
* Strengths
    * Efficiency
    * Portability
    * Power
    * Flexibility
    * Standard Library
    * Integration with UNIX
* Weaknesses
    * C programs can be error-prone
    * C program can be diffilcult to understand
    * Difficult to modify
</code></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="y5kc" id="2-c-fundamentals">2. C Fundamentals</h2><div class="md-section-divider"></div><h3 data-anchor-id="uj9f" id="21-compiling-and-linking">2.1 Compiling and Linking</h3><ul data-anchor-id="z04p">
<li>Preprocessing <br>
<ul><li>Preprocessor checks commands that begin with # - directives</li></ul></li>
<li>Compiling <br>
<ul><li>A compiler translates the source code into object code (machine instructions)</li></ul></li>
<li>Linking <br>
<ul><li>A linker combines the object code produced by the compiler with any additional code needed</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="u9np" id="22-general-form-of-a-simple-program">2.2 General Form of a Simple Program</h3><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="3t6w" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="typ">Directives</span></code></li><li class="L1"><code class="language-C"><span class="com">#include</span><span class="str">&lt;stdio.h&gt;</span></code></li><li class="L2"><code class="language-C"><span class="com">//to indicate that information in &lt;stdio.h&gt; is to be included.</span></code></li><li class="L3"><code class="language-C"><span class="typ">Functions</span></code></li><li class="L4"><code class="language-C"><span class="typ">Library</span><span class="pln"> </span><span class="typ">Functions</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="typ">User</span><span class="pln"> </span><span class="typ">Functions</span></code></li></ol></pre><ul data-anchor-id="1bt4">
<li>Notes:  <br>
<ul><li>main function is mandatory <br>
<ul><li>main should return 0</li>
<li>terminate</li>
<li>signal state</li></ul></li>
<li>Statements <br>
<ul><li>A statement is a command to be executed when the program runs.</li>
<li>Function call and return statement</li></ul></li>
<li>String Literal <br>
<ul><li>a series of characters enclosed in double quotation marks</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="todf" id="23-comments">2.3 Comments</h3><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="0uou" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">/* comments */</span></code></li><li class="L1"><code class="language-C"><span class="com">// comments</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="xt1y" id="24-variables-and-assignment">2.4 Variables and Assignment</h3><ul data-anchor-id="8yos">
<li>Definition <br>
<ul><li>data storage locations are called variables</li></ul></li>
<li>Types <br>
<ul><li>Type specifies what kind of data to hold</li></ul></li>
<li>Declarations <br>
<ul><li>Variables must be declared before use</li>
<li>type + variable name</li>
<li>C99 does not require all declarations to be before statements, but it's a convention</li></ul></li>
<li>Assignment <br>
<ul><li>A variable can be given a value by means of assignment.</li>
<li>Initialization <br>
<ul><li>uninitialized: values that have been declared but not assigned a value yet</li>
<li>intializer: int height = 8;</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="kvuj" id="25-defining-names-for-constants">2.5 Defining Names for Constants</h3><ul data-anchor-id="kvgk">
<li>Macro Definition</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="q1kc" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#defineINCH_PER_POUND 166</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> VALUE </span><span class="pun">(</span><span class="lit">1.0f</span><span class="pun">/</span><span class="lit">3.14159f</span><span class="pun">)</span></code></li><li class="L2"><code class="language-C"><span class="com">//a preprocessing directive</span></code></li></ol></pre><ul data-anchor-id="myfh">
<li>Identifiers and Keywords <br>
<ul><li>Identifiers Definition <br>
<ul><li>Names of variables, functions, macros, and other entiries are called identifiers.</li></ul></li>
<li>Rule <br>
<ul><li>can contain letters, digits, and underscores, but must begin with a letter or underscore</li>
<li>Case sensitive</li></ul></li>
<li>Keywords <br>
<ul><li>Keywords have special significance to C compilers and therefore cannot be used as identifiers.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="evn7" id="26-layout-of-a-c-program">2.6 Layout of a C Program</h3><ul data-anchor-id="cdtc">
<li>Tokens <br>
<ul><li>groups of characters that can't be split up without changing their meaning.</li></ul></li>
<li>Space <br>
<ul><li>has no influence</li>
<li>Statements can be divided over any number of Lines. </li>
<li>Space between Jokens makes it easier for the eye to separate them. </li>
<li>Indentation can make nesting easier to spot.</li>
<li>Blank lines can divide a program into logical units.</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="7pq7" id="3-formatted-inputoutput">3. Formatted Input/Output</h2><ul data-anchor-id="cwp0">
<li>The printf Function <br>
<ul><li>Function <br>
<ul><li>printf(string, expr1, expr2, ...);</li></ul></li>
<li>Conversion Specifications <br>
<ul><li>Functionality <br>
<ul><li>a placeholder representing a value to be fi lled in during printing</li>
<li>The information that follows the %- character specifies bow the value is converted :ti-om its internal form (binary) to printed form (cbaracters)</li></ul></li>
<li>Format <br>
<ul><li>%-m.pX (where m and p are integer constants and X is a letter)</li>
<li>Both m and pare optional; if p is orn.itted, the period that separates m and p is also dropped.</li>
<li>The minimum field width, m, specifies lhe minimum number of characters to print.</li>
<li>The meaning of the precision depends on the choice of X, the conversion specifier</li></ul></li>
<li>Common Conversion Specifier <br>
<ul><li>d- Displays an integer in decimal (base I0) form.</li>
<li>e - Displays a floating-point number in exponential format (scientific notation).</li>
<li>f - Displays a floating-point number in "fixed decimal" format, without an exponent. </li>
<li>g - Displays a tloating-point number in either exponential format or fixed decimal format. depending on the number's site. </li>
<li>Escape Sequences</li>
<li>Alert (bell) \a</li>
<li>Backspace \b</li>
<li>New line \n</li>
<li>Horizontal tab \ t </li></ul></li></ul></li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="5mpj" id="4-expressions">4. Expressions</h2><div class="md-section-divider"></div><h3 data-anchor-id="yixu" id="41-introduction">4.1 Introduction</h3><ul data-anchor-id="44od">
<li>C emphasizes expressions rather than statements</li>
<li>Expressions are built from variables, constants, and operators.</li>
</ul><div class="md-section-divider"></div><h2 data-anchor-id="wr9t" id="42-operators">4.2 Operators</h2><ul data-anchor-id="hqin">
<li>Arithmetic Operators</li>
<li>Unary Arithmetic Operators <br>
<ul><li>+/- to show the sign of a number</li></ul></li>
<li>Binary Arithmetic Operators <br>
<ul><li><ul><li>addition</li></ul></li>
<li><ul><li>subtraction</li></ul></li>
<li><ul><li>multiplication</li></ul></li>
<li>/ division</li>
<li>% remainder</li></ul></li>
<li>Implementation-Defined Behaviour <br>
<ul><li>The behavior when / and % are used with negative operands is implementation-defined in C89.</li>
<li>In C99, the result of a division is always truncated toward zero and the value of i % j has the same sign as i.</li></ul></li>
<li>Operator Precedence <br>
<ul><li>Highest + -</li>
<li>Middle * / %</li>
<li>Lowest + -</li></ul></li>
<li>Operator Associativity <br>
<ul><li>An operator is said to be left associative if it groups from left to right.</li>
<li>The binary arithmetic operators (*, /, %, +, and -) are all left associative</li>
<li>An operator is right associative if it groups from right to left.</li>
<li>The unary arithmetic operators (+ and -) are both right associative</li></ul></li>
<li>Relational Operators</li>
<li>Logical Operators</li>
<li>Assignment Operators <br>
<ul><li>Simple assignment <br>
<ul><li>used for storing a value into a variable</li>
<li>The effect of the assignment v = e is to evaluate the expression e and copy its value into v.</li>
<li>If v and e don’t have the same type, then the value of e is converted to the type of v as the assignment takes place.</li>
<li>in C, however, assignment is an operator, just like +. <br>
<ul><li>The value of an assignment v = e is the value of v after the assignment.</li></ul></li></ul></li>
<li>Side Effect <br>
<ul><li>An operators that modifies one of its operands is said to have side effect.                * Since assignment is an operator, several assignments can be chained together: <br>
<ul><li>i = j = k = 0;</li></ul></li>
<li>The = operator is right associative, so this assignment is equivalent to i = (j = (k = 0));</li>
<li>Lvalues <br>
<ul><li>The assignment operator requires an lvalue as its left operand.</li>
<li>An lvalue represents an object stored in computer memory, not a constant or the result of a computation.</li></ul></li>
<li>Compound Assignment <br>
<ul><li>used for updating a value already stored in a variable</li>
<li>There are nine other compound assignment operators, including the following: -= *= /= %=</li></ul></li></ul></li></ul></li>
<li>Increment and Decrement Operators <br>
<ul><li>C provides special ++ (increment) and -- (decrement) operators.</li>
<li>The ++ operator adds 1 to its operand. The -- operator subtracts 1.</li>
<li>They can be used as prefix operators (++i and –-i) or postfix operators (i++ and i--).</li>
<li>++i means “increment i immediately,” while i+ + means “use the old value of i for now, but increment i later.”</li></ul></li>
<li>Undefined Behaviour <br>
<ul><li>Statements such as c = (b = a + 2) - (a = 1); and j = i * i++; cause undefined behavior.</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="arlo" id="5-selection-statements">5. Selection Statements</h2><p data-anchor-id="6ssx">This Content is omitted.</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="bwln" id="6-loops">6. Loops</h2><p data-anchor-id="yd14">This Content is omitted.</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="luva" id="7-basic-types">7. Basic Types</h2><hr><div class="md-section-divider"></div><h2 data-anchor-id="9via" id="8-arrays">8. Arrays</h2><div class="md-section-divider"></div><h3 data-anchor-id="i91s" id="81-definitions">8.1 Definitions</h3><ul data-anchor-id="r62g">
<li>An array is a data structure containing a number of data values, all of which have the same type.</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8qsd" id="82-one-dimensional-arrays">8.2 One-Dimensional Arrays</h3><ul data-anchor-id="7zu6">
<li>Array Subscripting <br>
<ul><li>To access a particular element of an array. we write the atTay name followed by an integer value in square brackets (this is referred to as subscripting or indexing the array).</li></ul></li>
<li>Initialization <br>
<ul><li>Array Initializer <br>
<ul><li>The common form of array initializer is a list of constant expressions enclosed in braces and separaLed by commas</li>
<li>If the initializer is smaller than the array. the remaining elements of the array are given the value 0</li>
<li>If an initializer is present, the length of the array may be omitted</li></ul></li>
<li>Designated Initializers <br>
<ul><li>int a[l5] = {[2] = 29, [9] = 7, [14] = 48};</li>
<li>Each number in b rackets is said to be a designator. </li>
<li>Designators must be integer constant expressions.</li></ul></li>
<li>Using the sizeof Operator with Arrays <br>
<ul><li>The sizeof operator can detemine the size of an array (in bytes).</li>
<li>(sizeof (a) / sizeof (a [0])</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="mfnc" id="83-multidimensional-arrays">8.3 Multidimensional Arrays</h3><ul data-anchor-id="7qdg">
<li>Functionality <br>
<ul><li>An array may have any number of dimensions. </li>
<li>C stores arrays in row-major order, wilh row 0 first, then row l. and so forth. </li></ul></li>
<li>Initializing a Multidimensional Array <br>
<ul><li>We can create an initializer for a tw
</li><li>If an initializer is large enough to fiU a multidimensional array. the remaining elements are given the value 0.</li>
<li>If an inner list is not  enough to fill a row, rhe remaining elements in the row are initialized to 0.</li>
<li>We can even omit the inner braces.</li>
<li>In C99, designated initializers work with multidimensional arrays</li></ul></li>
<li>Constant Arrays</li>
<li>An array thafs been declared canst should not be modified by the program</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="jgdp" id="84-variable-length-arrays">8.4 Variable-Length Arrays</h3><pre data-anchor-id="387u"><code>* only supported in C99
</code></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="omfl" id="9-functions">9. Functions</h2><div class="md-section-divider"></div><h3 data-anchor-id="dgpl" id="91-format">9.1 format</h3><ul data-anchor-id="krz1">
<li>Write a Function <br>
<ul><li>[return type] [function name] (parameters) { body }</li></ul></li>
<li>Call a function <br>
<ul><li>function name (arguments);</li></ul></li>
<li>Definitions <br>
<ul><li>Functions may not return arrays. but there are no other restrictions on the return type. </li>
<li>Specifying that the return Lype is void indicates that the function doesn't return a value. </li>
<li>lf the return type is omitted in C89, the function is presumed to retum a value of type int. In C99. it's illegal to omit the return type of a function. </li>
<li>Variables declared in the body of a runction belong exclusively to that function: they can't be examined or modified by other functions. </li></ul></li>
<li>Function Declarations</li>
<li>Implicit Declarations <br>
<ul><li>a definition of a function is present prior to any call of the function</li></ul></li>
<li>Function Declaration</li>
<li>a declaration of a function is present prior to any call of the function</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="5xjb" id="92-arguments">9.2 Arguments</h3><ul data-anchor-id="53pi">
<li>Argument Passing <br>
<ul><li>In C, arguments are passed by value except for array.</li></ul></li>
<li>Argument Conversions <br>
<ul><li>The compiler governing how the arguments are converted depends on whether or not the compiler has seen a prototype for the funcrion (or the function· s full definition) prior to the call.</li>
<li>YES - &gt; each argument is implicitly converted</li>
<li>NO -&gt; default argument promotions <br>
<ul><li>1) float to be double</li>
<li>2) char and short to int</li></ul></li></ul></li>
<li>Array Argument <br>
<ul><li>we may have to provide the length as one argument</li></ul></li>
<li>Variable-Length Array Parameters <br>
<ul><li>(int n, int a[n])</li></ul></li>
<li>Compound Literals <br>
<ul><li>total= sum_array((int []){3, 0, 3, 4, 1}, 5); </li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="5f7l" id="93-the-return-statement">9.3 The return Statement</h3><ul data-anchor-id="umu2">
<li>Program Termination <br>
<ul><li>Return in Main</li>
<li>Older C programs often omit main's return type, taking advantage of the fact that it traditionally defaults to int</li>
<li>The value returned by main is a status code that-in some operating systems can be tested when the program terminates.</li></ul></li>
<li>The exit Function <br>
<ul><li>exit(0);</li>
<li>exit(EXIT_SUCCESS);</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="y0l8" id="10-program-organization">10. Program Organization</h2><div class="md-section-divider"></div><h3 data-anchor-id="9c9b" id="101-local-variables">10.1 Local Variables</h3><ul data-anchor-id="bc8k">
<li>Introduction <br>
<ul><li>Definition <br>
<ul><li>A variable declared in the body of a function is said to be local to the function.</li></ul></li>
<li>Property <br>
<ul><li>Automatic storage duration</li>
<li>Block scope</li></ul></li>
<li>Static Local Variables <br>
<ul><li>Puting static in the declaration of a local variable causes it to have static storage duration.</li>
<li>Static variable has a permanent storage location, so it retains its value throughout the program.</li>
<li>A static local variable still has block scope, so it's not visible to other functions.</li></ul></li>
<li>Parameters <br>
<ul><li>parameters have the same properties as local variables.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="9dqa" id="102-external-variables">10.2 External Variables</h3><ul data-anchor-id="aab7">
<li>Definition <br>
<ul><li>Functions can also communicate through external variables - variables that are declared outside the body of any function.</li></ul></li>
<li>Propertiies <br>
<ul><li>Static storafe duration</li>
<li>File scope</li></ul></li>
<li>Pros and Cons of External Variables <br>
<ul><li>Cons <br>
<ul><li>If we change an external variable during maintenance, we'll need to check every function.</li>
<li>If an external variable is assigned an incorrect value, it may be difficult to identify the guilty function</li>
<li>Functions that rely on external variables are hard to reuse.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="gsc7" id="103-blocks">10.3 Blocks</h3><ul data-anchor-id="9fos">
<li>The storage duration of a varaibled declared in a block is automatic: storage for the variable is allocated when the block is entered and deallocated when the block is exited.</li>
<li>The variable has block scope.</li>
<li>A variable that belongs to a block can be declared static to give it static storage duration.</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="roiy" id="104-scope">10.4 Scope</h3><ul data-anchor-id="iuta">
<li>When a declaration inside a block names an identifier that's already visible (because it has file scope or because it is declared in an enclosing block), the new declaration temporarily hides the old one, and the identifier takes on a new meaning.</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="c4zi" id="105-organizing-a-c-program">10.5 Organizing a C Program</h3><ul data-anchor-id="7zan">
<li>Format</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="rbof" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#include</span><span class="pln"> directives</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> directives</span></code></li><li class="L2"><code class="language-C"><span class="typ">Type</span><span class="pln"> definitions</span></code></li><li class="L3"><code class="language-C"><span class="typ">Declarations</span><span class="pln"> of external variables</span></code></li><li class="L4"><code class="language-C"><span class="typ">Prototypes</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> functions other than main</span></code></li><li class="L5"><code class="language-C"><span class="typ">Defnition</span><span class="pln"> of main</span></code></li><li class="L6"><code class="language-C"><span class="typ">Definitions</span><span class="pln"> of other functions</span></code></li></ol></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="v28q" id="11-pointers">11. Pointers</h2><div class="md-section-divider"></div><h3 data-anchor-id="p0u3" id="111-pointer-variables">11.1 Pointer Variables</h3><ul data-anchor-id="hc3s">
<li>Declaring Pointer Variable <br>
<ul><li>the name of a pointer variable must be preceded by an asterisk.</li>
<li><code>int *p;</code> </li>
<li>This declaration states that p is a pointer variable capable of pointing to objects of type int. </li>
<li>Pointer variables can appear in declarations along with other variables;</li>
<li>C requires that every pointer variable point only to objectc; of a particular type (the referenced type)</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8fyq" id="112-the-address-and-indirection-operators">11.2 The Address and Indirection Operators</h3><ul data-anchor-id="safu">
<li>The Address Operator &amp; <br>
<ul><li><code>p = &amp;i;</code> </li></ul></li>
<li>The Indirection Operator * <br>
<ul><li>Once a pointer variable points to an object. we can use the * (indirection) operator to access whar's stored in the object.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="339v" id="113-pointer-assignment">11.3 Pointer Assignment</h3><ul data-anchor-id="duuc">
<li>C allows the use of assignment operator to copy pointer, provided that they have the same type.</li>
<li>Any number of pointer variables may point to the same object. </li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="9hoo" id="114-pointer-as-arguments">11.4 Pointer as Arguments</h3><ul data-anchor-id="bcpn">
<li>Modify Arrays</li>
<li>Return Two Results</li>
<li>Scan Function</li>
<li>Using const to Protect Argument <br>
<ul><li>We can use the word const to document that a function won't change an object whose address is passed to the function. cons t goes in the parameter's E!l11 declaration, just before the specification of its type</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="03wd" id="115-pointers-as-return-values">11.5 Pointers as Return Values</h3><ul data-anchor-id="97lj">
<li>Then the variable has to be decaled as static</li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="r3a6" id="12-pointers-and-arrays">12. Pointers and Arrays</h2><hr><div class="md-section-divider"></div><h2 data-anchor-id="twlk" id="13-strings">13. Strings</h2><hr><div class="md-section-divider"></div><h2 data-anchor-id="0b4t" id="14-the-preprocessor">14. The Preprocessor</h2><div class="md-section-divider"></div><h3 data-anchor-id="efzo" id="141-how-the-preprocessor-works">14.1 How the Preprocessor Works</h3><ul data-anchor-id="6zl4">
<li>The behavior of the preprocessor is controlled by <strong>preprocessing directives</strong>: commands that begin with a # character.  <br>
<ul><li>The <strong>#define directive</strong> defines a <strong>macro</strong> - a name that represents something else, such as a constant or frequently used expression. </li>
<li>The <strong>#include</strong> directive tells the preprocessor to open a pruticular file and "include" its contents as part of the file being compiled. </li></ul></li>
<li>The Process of Preprocessing <br>
<ul><li>The input to the preprocessor is a C program, possibly containing directives. </li>
<li>The preprocessor executes these directives, removing them in the process. </li>
<li>The output of the preprocessor is another C program: an edited version of the origjnal program, containing no directives. </li>
<li>The preprocessor's output goes directly into the compiler. which checks the program for errors and translates it to object code.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="2txc" id="142-preprocessing-directives">14.2 Preprocessing Directives</h3><ul data-anchor-id="rvol">
<li>Most preprocessing directives fall into one of three categories:  <br>
<ul><li><strong>Macro definition</strong>: The #define directive defines a macro; the #undef directive removes a macro definition. </li>
<li><strong>File inclusion</strong>: The #include directive causes Lhe contents of a specified file to be included in a program. </li>
<li><strong>Conditional compilation</strong>: the #if, #ifdef, #ifndef, #eli£, #else, and #endif directives allow blocks of text to be either included in or excluded from a program, depending on conditions that can be tested by the preprocessor. </li></ul></li>
<li>There are a few rules that apply to all directives <br>
<ul><li>Directives always begin with the <strong># symbol</strong>.</li>
<li>Any number of spaces and horizontal tab characters may <strong>separate the tokens</strong> in a directive. </li>
<li>Directives always <strong>end at the first new-line character</strong>, unless explicitly continued.</li>
<li>Directives can appear <strong>anywhere</strong> in a program. </li>
<li><strong>Comments</strong> may appear on the same line as a directive. </li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8i8p" id="143-macro-definitions">14.3 Macro Definitions</h3><ul data-anchor-id="vp5l">
<li>Simple Macros <br>
<ul><li>The definition of a <strong>simple macro</strong> (or <strong>object-like macro</strong>, as it·s called in the C standard) has the form, <code>#define identifier replacement-list</code>, where replacement-list is any sequence of <strong>preprocessing tokens</strong>.</li>
<li>When it encounters a macro definition, the preprocessor makes a note that identifier represents replacement-list; wherever identifier appears later in the file, the preprocessor substitutes replacement-list. </li>
<li>lncidentnlly. it's legal for a macro's replacement list to be empty.</li></ul></li>
<li>Use #define to create names for constants has several significant advantages <br>
<ul><li>It makes programs easier to read.</li>
<li>It makes programs easier to modify</li>
<li>It helps avoid inconsistencies and typographical errors.</li>
<li>Making minor changes to the syntax of C <br>
<ul><li>like: <code>#define BEGIN {</code> or <code>#define END }</code></li></ul></li>
<li>Renaming types. <br>
<ul><li><code>#define BOOL int</code></li></ul></li>
<li>Controlling conditional compilation</li></ul></li>
<li><p>Parameterized Macros</p>

<ul><li>The definition of a <strong>parameterized macro</strong> (also known as a function-like macro) has the form <code>#define identifier( x1, x2, x3, x4, ..., xn) replacement-list</code> <br>
<ul><li>There must be no space between the macro name and the left parenthesis. lf space is left. the preprocessor will assume tbat we're defining a simple macro; it will treat (x 1 , x2 ,..., xn,) as part of the replacement list. </li></ul></li>
<li>Using a parameterized macro instead of a true function has a couple of advantages <br>
<ul><li>The program may be slightly faster. (however, the C99's inline functions provide a way to avoid this overhead without the use of macros)</li>
<li>Macros are generic </li></ul></li>
<li>But parameterized macros also have disadvantages <br>
<ul><li>The compiled code will often be larger.</li>
<li>Arguments aren't type-checked.</li>
<li>It's not possible to have a pointer to a macro.</li>
<li>A macro may evaluate its arguments more than once. <br>
<ul><li>like <code>n = MAX(i++, j);</code></li></ul></li></ul></li></ul></li>
<li><p>The # Operator</p>

<ul><li><strong>The # operator</strong> convet s a macro argument into a string iteral</li>
<li>it can appear only in rhe replacement list of a parameterized macro. </li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="cuwo" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#define</span><span class="pln"> PRINT_INT</span><span class="pun">(</span><span class="pln">n</span><span class="pun">)</span><span class="pln"> printf</span><span class="pun">(#</span><span class="pln">n </span><span class="lit">11</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="pln">d\n</span><span class="str">", n) </span></code></li><li class="L1"><code class="language-C"><span class="str">PRINT_INT(i/j); </span></code></li><li class="L2"><code class="language-C"><span class="str">//which is equivalent to</span></code></li><li class="L3"><code class="language-C"><span class="str">printf("</span><span class="pln">i</span><span class="pun">/</span><span class="pln">j</span><span class="str">" "</span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="pln">d\n</span><span class="str">", i/j); </span></code></li><li class="L4"><code class="language-C"><span class="str">/*which is equivalent to</span></code></li><li class="L5"><code class="language-C"><span class="str">printf("</span><span class="pln">i</span><span class="pun">/</span><span class="pln">j </span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="pln">d\n</span><span class="str">", i/j); </span></code></li></ol></pre><ul data-anchor-id="ou5b">
<li><p>The ## Operator </p>

<ul><li>The ## opcrawr can "paste" two mkens (idemHiers. for example) together to form a single token. </li></ul></li>
<li><p>General Properties of Macros</p></li>
<li>Creating Longer Macros</li>
<li>Predefined Macros</li>
<li>Additional Predefined Macros in C99</li>
<li>Empty Macro Arguments</li>
<li>Macros with a Variable Number of Arguments</li>
<li>The __func__ identifier </li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="fb77" id="144-conditional-compilation">14.4 Conditional Compilation</h3><ul data-anchor-id="u47l">
<li>The #if and #endif Directives</li>
<li>The defined Operator</li>
<li>The #ifdef and #ifndef Directives</li>
<li>The #elif and #else Directives</li>
<li>Uses of Conditional Compilation</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="6002" id="145-miscellaneous-directives">14.5 Miscellaneous Directives</h3><ul data-anchor-id="b68u">
<li>The #error Directive</li>
<li>The #line Directive</li>
<li>The #progma Directive</li>
<li>The _Progma Operator</li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="w2c8" id="15-writing-large-programs">15. Writing Large Programs</h2><div class="md-section-divider"></div><h3 data-anchor-id="yxg5" id="151-source-files">15.1 Source Files</h3><ul data-anchor-id="irym">
<li>By convention, source files have the extension <strong>.c</strong>.</li>
<li>Each source file3 contains part of the program, primarily definitions of functions and variables <br>
<ul><li>One source file must contain a function named <strong>main</strong>, which serves as the starting point for the program.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="m1jn" id="152-header-files">15.2 Header Files</h3><ul data-anchor-id="c8h9">
<li>The #include Directive <br>
<ul><li>Usage <br>
<ul><li>The <code>#include</code> directive tells the preprocessor to open a specified file and insert its contents into the current file.</li>
<li>Thus, if we want several source files to have access to the same information, we'll put that information in a file and then use <code>#include</code> to bring the file's contents into each of the source files.</li>
<li>Files that are included in this fashion are called <strong>header files</strong>, and have the extension <code>.h</code>.</li></ul></li>
<li>Three forms <br>
<ul><li>The first form is used for header files that belong to C's own library <br>
<ul><li><code>#include &lt;filename&gt;</code></li>
<li>Search the directory in which system header files reside.</li></ul></li>
<li>The second form is used for all other header files, including any that we write: <br>
<ul><li><code>#include "filename"</code> </li>
<li>Search the current directory, then search the directory in which system header files reside.</li></ul></li>
<li>The third form involves the use of defined tokens, and is used less often. <br>
<ul><li><code>#include tokens</code></li>
<li>Tokens refer to any sequence of preprocessing tokens. The preprocessor will scan the tokens and replace any macros that it finds.</li>
<li>After macro replacement, the resultign directive must match one of the other forms of #include.</li>
<li>The advantage of the third one is that the file ame can be defined by a macro rather than being "hard-coded" into the directive itself.</li></ul></li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="xvsg" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#if defined(IA32)</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="com">#define</span><span class="pln"> CPU_FILE </span><span class="str">"ia32.h"</span></code></li><li class="L2"><code class="language-C"><span class="com">#elif</span><span class="pln"> </span><span class="kwd">defined</span><span class="pun">(</span><span class="pln">IA64</span><span class="pun">)</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="com">#define</span><span class="pln"> CPU_FILE </span><span class="str">"ia64.h"</span></code></li><li class="L4"><code class="language-C"><span class="com">#elif</span><span class="pln"> </span><span class="kwd">defined</span><span class="pun">(</span><span class="pln">AMD64</span><span class="pun">)</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="com">#define</span><span class="pln"> CPU_FILE </span><span class="str">"amd64.h"</span></code></li><li class="L6"><code class="language-C"><span class="com">#endif</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="com">#include</span><span class="pln"> CPU_FILE</span></code></li></ol></pre><ul data-anchor-id="8dmc">
<li>Sharing Macro Definitions and Type Definitios <br>
<ul><li>The definitons that need to be shared by several source files should go into the header files.</li>
<li>Advantages oPutting Definitions of macros and types in header files  <br>
<ul><li>Save time by not having to copy the definition into the source files where they're needed.</li>
<li>The program becomes easier to modify.</li>
<li>We don't have to worry about inconsistencies caused by source files containing different definitions of the same macro or type.</li></ul></li></ul></li>
<li>Sharing Functions Prototypes <br>
<ul><li>Always include the header file declaring a function in the source file that contain's that function's definition.</li>
<li>Failure to do so can cause hard-to-find bugs, since calls of f elsewhere in the program may not match f's definition.</li></ul></li>
<li>Sharing Variable Declarations <br>
<ul><li>Comparison <br>
<ul><li><code>int i;</code> <br>
<ul><li>This statement declares i to be a variable of type int, but also defines i by setting aside space for i.</li></ul></li>
<li><code>extern int a[];</code> <br>
<ul><li>This statement declares i without defining it.</li>
<li><code>extern</code> informs the compiler that i is defined elsewhere in the program (most likely in a different source file), so there is no need to allocate space for it.</li>
<li>Since the compiler doesn't allocate space for a at this time.</li></ul></li></ul></li>
<li>Usage <br>
<ul><li>To share a variable <code>i</code> among several files, the definition <code>int i;</code> should be first put into one file;</li>
<li>If i needs to be initialized, the initializer would go here too.</li>
<li>The other file should contain only the declaration of i: <code>extern int i;</code></li></ul></li>
<li>Caution <br>
<ul><li>To avoid inconsistency among all declarations, the declarations of shared variables are usually put put in header files.</li></ul></li></ul></li>
<li>Nested Includes <br>
<ul><li>A header file may itself contain <code>#include</code> directives.</li></ul></li>
<li>Protecting Header Files <br>
<ul><li>It's a good idea to protect all header files against multiple inclusion; <br>
<ul><li>To avoid causing a compilation error.</li>
<li>To avoid unnecessary recompilation of the same header file.</li></ul></li>
<li>To protect a header file, we'll enclose the contents of the file in an <code>#ifndef</code> and <code>#endif</code> pair.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="9oqj" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#ifndef</span><span class="pln"> BOOLEAN_H</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> BOOLEAN_H</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="com">#define</span><span class="pln"> TRUE </span><span class="lit">1</span></code></li><li class="L4"><code class="language-C"><span class="com">#define</span><span class="pln"> FALSE </span><span class="lit">0</span></code></li><li class="L5"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> </span><span class="typ">Bool</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="com">#endif</span></code></li></ol></pre><ul data-anchor-id="vxe3">
<li>#error Directives in Header Files <br>
<ul><li><code>#error</code> directives are often put in header files to check for conditions under which the header file shouldn't be included.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="q3f1" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#ifndef</span><span class="pln"> __STDC___</span></code></li><li class="L1"><code class="language-C"><span class="com">#error</span><span class="pln"> </span><span class="typ">This</span><span class="pln"> header requires a </span><span class="typ">Standard</span><span class="pln"> C compiler</span></code></li><li class="L2"><code class="language-C"><span class="com">#endif</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="loqo" id="153-divding-a-program-into-files">15.3 Divding a Program into Files</h3><ul data-anchor-id="lgvw">
<li>Include the definition of all the functions in a class (like foo.c).</li>
<li>include the prototypes of the functiosn defined in foo.c that are expected to be used in other functions in the header file (like foo.h)</li>
<li>include foo.h in foo.c so that the compiler can check that the function prototypes in foo.h are consistent with the definitions in foo.c.</li>
<li>The <code>main</code> function will go in a file whose name matches the name of the program - if we want the program to be known as bar, then the main should be in the file bar.c</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="lpo8" id="154-building-a-multiple-file-program">15.4 Building a Multiple-File Program</h3><ul data-anchor-id="dsq2">
<li>Process <br>
<ul><li>Compiling <br>
<ul><li>Each source file in the program must be compiled separately.</li>
<li>Header files don't need to be compiled as its contents are automatically compiled whenever a soruce file that includes it is compiled.</li>
<li>The files compiled are knwon as <strong>object files</strong>, and they have the extension .o in UNIX and .obj in Windows.</li></ul></li>
<li>Linking <br>
<ul><li>The linker combines the object files created in the previous step along with code for library functions to produce an executable file.</li></ul></li>
<li>Most compilers allow us to build a program in a single step <br>
<ul><li><code>gcc -o justify justify.c line.c word.c</code></li></ul></li></ul></li>
<li><p>Makefiles</p>

<ul><li>Introduction <br>
<ul><li>To make it easier to build large programs, UNIX originated the concept of the <strong>makefile</strong>, a file containing the information necessary to build a program.</li>
<li>A makefile not only lists the files that are part of the program, but also describes <strong>dependencies</strong> among the files.</li></ul></li>
<li>Definitions <br>
<ul><li>Below are four groups of lines, and each group is known as a <strong>rule</strong>.</li>
<li>The first line in each rule gives a <strong>target</strong> file, followed by the files on which it depends.</li>
<li>The decond line is a <strong>command</strong> to be executed if the target should need to be rebuilt because of a change to one of its dependent files.</li></ul></li>
<li>Cautions <br>
<ul><li>Each command in a makefile must be preceded by a tab character, not a series of spaces.</li>
<li>A makefile is normally stored in a file named Makefile (or makefile), and when the make utility is used, it automatically checks the current directory for a file with one of these names.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="67rz" style=""><ol class="linenums"><li class="L0"><code class="language-makefile"><span class="pln">justify</span><span class="pun">:</span><span class="pln"> justify</span><span class="pun">.</span><span class="pln">o word</span><span class="pun">.</span><span class="pln">c line</span><span class="pun">.</span><span class="pln">o</span></code></li><li class="L1"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">o justify justify</span><span class="pun">.</span><span class="pln">o word</span><span class="pun">.</span><span class="pln">o line</span><span class="pun">.</span><span class="pln">o</span></code></li><li class="L2"><code class="language-makefile"></code></li><li class="L3"><code class="language-makefile"><span class="pln">justify</span><span class="pun">.</span><span class="pln">o</span><span class="pun">:</span><span class="pln"> justify</span><span class="pun">.</span><span class="pln">c word</span><span class="pun">.</span><span class="pln">h line</span><span class="pun">.</span><span class="pln">h</span></code></li><li class="L4"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">c justify</span><span class="pun">.</span><span class="pln">c</span></code></li><li class="L5"><code class="language-makefile"></code></li><li class="L6"><code class="language-makefile"><span class="pln">word</span><span class="pun">.</span><span class="pln">o</span><span class="pun">:</span><span class="pln"> word</span><span class="pun">.</span><span class="pln">c word</span><span class="pun">.</span><span class="pln">h</span></code></li><li class="L7"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">c word</span><span class="pun">.</span><span class="pln">c</span></code></li><li class="L8"><code class="language-makefile"></code></li><li class="L9"><code class="language-makefile"><span class="pln">line</span><span class="pun">.</span><span class="pln">o</span><span class="pun">:</span><span class="pln"> line</span><span class="pun">.</span><span class="pln">c line</span><span class="pun">.</span><span class="pln">h</span></code></li><li class="L0"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">c line</span><span class="pun">.</span><span class="pln">c</span></code></li></ol></pre><ul data-anchor-id="2inq">
<li>Errors During Linking <br>
<ul><li>Misspelling</li>
<li>Missing files</li>
<li>Missing Libraries</li></ul></li>
<li>Rebuilding a Program <br>
<ul><li>To save time, the rebuilding process should recompile only those files that might be affected by the latest change.</li></ul></li>
<li>Defining Macros Outside a Program <br>
<ul><li>c compilers usually provide some method of specifying the value of a macro at the time a program is compiled, which is the -D function in gcc</li>
<li>Most compilers also support the -U option, which undefines a macro as if by using #undef.</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="1sa9" id="16-structures-unions-and-enumerations">16. Structures, Unions, and Enumerations</h2><div class="md-section-divider"></div><h3 data-anchor-id="0ru5" id="161-structure-variables">16.1 Structure Variables</h3><ul data-anchor-id="ymib">
<li>Introduction <br>
<ul><li>A <strong>structure</strong> is a collection of values, possibly of different types.</li>
<li>The elements of a structure, its <strong>member</strong>, aren't reuired to have the same type.</li>
<li>The members of a structure have names - therefore to select a particular member, we specify its name, not its position.</li></ul></li>
<li>Declaring Structure Variables <br>
<ul><li>In the codes below, <code>struct{ ... }</code> specifies a type, while <code>part1</code> and <code>part2</code> are variables of that type.</li>
<li>'The members of a structure are stoed in memory in the order in which they are declared.</li>
<li>Each structure represents a new scope; any names declared in that scope won't conflict with other names in a program - each structure has a separate <strong>name space</strong> for its members.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ik5e" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part1</span><span class="pun">,</span><span class="pln"> part2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="7bcq">
<li>Initializing Structure Variables <br>
<ul><li>A structure variable may be initialized at the time it's declared.</li>
<li>To initialize a structure, we prepare a list of values to be stored in the structure and enclose it in braces.</li>
<li>The values in the initializer must appear in the same order as the members of the structure.</li>
<li>Structure initializers follow rules similar to those for array initializer. <br>
<ul><li>Expressions used in a structure initializer must be constant (but this restriction is relaxed in C99)</li>
<li>An initializer can have fewer members than the structure it's initializing. Any leftover members are given 0 as their initial value.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="0w1w" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">527</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">},</span></code></li><li class="L5"><code class="language-C"><span class="pln"> part2 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">914m</span><span class="pln"> </span><span class="str">"Printer cable"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5</span><span class="pun">};</span></code></li></ol></pre><ul data-anchor-id="lj0s">
<li>Designated Initializers <br>
<ul><li>In a designated initializer, each value labeled by the name of of the member that it nitializes. <br>
<ul><li>The combination of the period and the member name is called a <strong>designator</strong></li></ul></li>
<li>Designated initializers have several advantages. <br>
<ul><li>They are easier to read and check for correctness.</li>
<li>The values in the initializer don't have to be placed in the same order that the members are listed in the structure.</li>
<li>The order of the members can be changed in the future without affecting designated initializers.</li></ul></li>
<li>Not all values listed in a designated initializer need to be prefixed by a designator.</li>
<li>Any members that the initializer fails to account for are set to zero.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="hh4i" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> </span><span class="lit">527</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">on_hand </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">},</span></code></li><li class="L5"><code class="language-C"><span class="pln"> part2 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> </span><span class="lit">527</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">on_hand </span><span class="pun">=};</span></code></li></ol></pre><ul data-anchor-id="myb2">
<li>Operations on Structures <br>
<ul><li>To access a member within a structure, we write the name of the structure first, then a period, then the name of the member.<br><code>part1.number</code></li>
<li>The members of a structure are lvalues, so they can appear on the left side of an assignment or as the operand in an increment or decrement expression.<br><code>part1.number = 258</code><br><code>part1.on_hand++;</code></li>
<li>The . period that we use to access a structure member is actuallt a C operator, and it has the same precedence as the postfix ++ and -- operators, so it takes precedence over nearly all other operators.</li>
<li>The other major structure operation is assignment:<br><code>part2 = part1;</code><br>The effect of this statement is to copy <code>part1.number</code> into <code>part2.number</code>, <code>part1.name</code> into <code>part2.name</code>and so on. <br>
<ul><li>The = operator can be used only with structures of <strong>compatible</strong> types.</li>
<li>Two structures declared at the same time are compatible.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="2vu5" id="162-structure-types">16.2 Structure Types</h3><ul data-anchor-id="89qh">
<li>Introduction <br>
<ul><li>If we want to declare a variable of a structure first, and then declare another one at a later time, without the type of the structure, we would have to write the structure twice.</li>
<li>This leads to two difficuties <br>
<ul><li>One is that the program will soon be bloated to be too large.</li>
<li>The other is that those two variables declared at different time and position will be considered to be not compatible, so they cannot assign value to each other.</li></ul></li></ul></li>
<li>Declaring a Structure Tag <br>
<ul><li>A <strong>structure tag</strong> is a name used to identify a particular kind of structure.</li>
<li>Once we've created the name tag, we can use it to declare variables, but we can't drop the word <code>struct</code>. <br>
<ul><li>Since structures tags aren't recognized unless preceded by the word <code>struct</code>, they don't conflict with other names used in a program.</li>
<li>The declaration of a structure tag can be conbined with the declaration of structure variables;</li>
<li>Declaring a structure tag is mantatorg when structure is to be used in a linked list.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="3sfu" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NALE_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part3</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part part1</span><span class="pun">,</span><span class="pln"> part2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="pwfk">
<li>Defining a Structure Type <br>
<ul><li>We can use <code>typedef</code> to define a genuine type name. <br>
<ul><li>The name of the type must come at the end, not after the word struct.</li>
<li>Then we can use the name of the type in the same way as the built-in types, without using together with the <code>struct</code>.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="qn48" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln"> </span><span class="typ">Part</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="typ">Part</span><span class="pln"> part1</span><span class="pun">,</span><span class="pln"> part2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="6kxp">
<li>Structures as Arguments and Return Values <br>
<ul><li>Passing a structure to a function and returning a structure from a function both require making a copy of all members in the structure. <br>
<ul><li>As a result, these operations impose a fair amount of overhead on a program, especially if the structure is large.</li>
<li>To avoid this overhead, it is sometimes advisable to pass a structure pointer instead of the structure itself.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="h7dg" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">/*Structures as Argument*/</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">void</span><span class="pln"> print_part</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> part p</span><span class="pun">){</span></code></li><li class="L3"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Part number: %d\n"</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">number</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Part name: %s\n"</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Quantity on hand: %d\n"</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">on_hand</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bc5u" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">/*Structure as Return Value*/</span></code></li><li class="L1"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part build_part</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> part p</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="pln">    p</span><span class="pun">.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">    strcpy</span><span class="pun">(</span><span class="pln">p</span><span class="pun">.</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">    p</span><span class="pun">.</span><span class="pln">on_hand </span><span class="pun">=</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part part1 </span><span class="pun">=</span><span class="pln"> build_part</span><span class="pun">(</span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span></code></li></ol></pre><ul data-anchor-id="7fcf">
<li>Compound Literals <br>
<ul><li>Compound literals were used to create unnamed arrays, usually for the purpose of passing the array to a function.</li>
<li>A compound literal can also be used to create a structure "on the fly", without first storing it in a variable. <br>
<ul><li>The resulting structure can be passed as a parameter, returned by a function, or assigned to a variable.</li>
<li>in general, a compound literal consists of a type name within parentheses, followed by a set of values enclosed by braces.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="1jhj" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">print_part</span><span class="pun">((</span><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">){</span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">});</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part part1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">){</span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">};</span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="pln">print_part</span><span class="pun">((</span><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">){.</span><span class="pln">on_hand </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> </span><span class="lit">528</span><span class="pln"> </span><span class="pun">});</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="jo7r" id="163-nested-arrays-and-structures">16.3 Nested Arrays and Structures</h3><ul data-anchor-id="gkdm">
<li>Nested Structures</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="xzuq" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> person_name</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> first</span><span class="pun">[</span><span class="pln">FIRST_NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> middle_initial1</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> </span><span class="kwd">last</span><span class="pun">[</span><span class="pln">LAST_NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L4"><code class="language-C"><span class="pun">};</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="kwd">struct</span><span class="pln"> student </span><span class="pun">{</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> person_name name</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> id</span><span class="pun">,</span><span class="pln"> age</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> sex</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pun">}</span><span class="pln"> student1</span><span class="pun">,</span><span class="pln"> student2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="vojb">
<li>Arrays of Structures</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ccw5" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part inventory</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span></code></li></ol></pre><ul data-anchor-id="p8nb">
<li>Initializing an Array of Structures <br>
<ul><li>In initializing an array of structures, each structure has its own brace-enclosed intializer, and the initializer for the array simply wraps another set of braces around the structre initializers.</li>
<li>One reason for initializing an array of structures is that we are planning to treat it as a database of information that won't change during program execution.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="q8es" id="164-unions">16.4 Unions</h3><ul data-anchor-id="hyhl">
<li>Using Unions to Save Space <br>
<ul><li>Definition <br>
<ul><li>A <strong>union</strong> consists of one or more members, possible of different types.</li>
<li>However, the compiler allocates only enough space for the larggest of the members, which overlay each other within this space.</li>
<li>As a result, assigning a new value to one member alters the values of the other members as well.</li></ul></li>
<li>Property <br>
<ul><li>The properties of unions are almost identical to the properties of structures.</li>
<li>Unions can be initialized in a manner similar to structures, but only one member can be initialized whether it's the default initializer or the designated initializer. </li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="wbrn" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> catalog_item</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> stock_numer</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">double</span><span class="pln"> price</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> item_type</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">union</span><span class="pun">{</span></code></li><li class="L5"><code class="language-C"><span class="pln">        </span><span class="kwd">struct</span><span class="pun">{</span><span class="kwd">char</span><span class="pln"> title</span><span class="pun">[</span><span class="pln">TITLE_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">char</span><span class="pln"> author</span><span class="pun">[</span><span class="pln">AUTHOR_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L7"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> num_pages</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">book</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L0"><code class="language-C"><span class="pln">        </span><span class="kwd">char</span><span class="pln"> design</span><span class="pun">[</span><span class="pln">DESIGN_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">mug</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L3"><code class="language-C"><span class="pln">        </span><span class="kwd">char</span><span class="pln"> design</span><span class="pun">[</span><span class="pln">DESIGN_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L4"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> colors</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> sizes</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">shirt</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pun">}</span><span class="pln">item</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="u20z">
<li>Using Unions to Build Mixed Data Structures</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="x053" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">union</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">double</span><span class="pln"> d</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span><span class="typ">Number</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="typ">Number</span><span class="pln"> number_array</span><span class="pun">[</span><span class="lit">1000</span><span class="pun">];</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="pln">number_array</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">number_array</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">d </span><span class="pun">=</span><span class="pln"> </span><span class="lit">8.395</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="6md5">
<li>Adding a "Tag Field" to a Union <br>
<ul><li>There is no easy way to tell which member of a union was last changed and therefore contains a meaningful value.</li>
<li>In order to keep track of this information, we can embed the union within a structure that has one other member: a <strong>tag field</strong> or a <strong>discriminant</strong>, whose purpose is to remind us what's currently stored in the union.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="0rag" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#define</span><span class="pln"> INT_KIND </span><span class="lit">0</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> DOUBLE_KIND </span><span class="lit">1</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> kind</span><span class="pun">;</span><span class="pln">       </span><span class="com">/* tag field */</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="kwd">union</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pln">        </span><span class="kwd">double</span><span class="pln"> d</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">u</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span><span class="typ">Number</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="typ">Number</span><span class="pln"> n</span><span class="pun">;</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="h7yg" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">n</span><span class="pun">.</span><span class="pln">kind </span><span class="pun">=</span><span class="pln"> INT_KIND</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">n</span><span class="pun">.</span><span class="pln">u</span><span class="pun">.</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">82</span><span class="pun">;</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="sv3y" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">void</span><span class="pln"> print_number</span><span class="pun">(</span><span class="typ">Number</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">n</span><span class="pun">.</span><span class="pln">kind </span><span class="pun">==</span><span class="pln"> INT_KIND</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">.</span><span class="pln">u</span><span class="pun">.</span><span class="pln">i</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="kwd">else</span><span class="pun">{</span></code></li><li class="L4"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln">n</span><span class="pun">.</span><span class="pln">u</span><span class="pun">.</span><span class="pln">d</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="el49" id="165-enumerations">16.5 Enumerations</h3><ul data-anchor-id="0anj">
<li>Definition <br>
<ul><li>A <strong>enumerated type</strong> is a type whose values are listed ("enumerated") by the programmer, who must create a name (an <strong>enumeration constant</strong>) for each of the values.</li>
<li>The names of enumeration constants must be different from other identifiers declared in the enclosing scope.</li>
<li>Enumeration constants are subject to C's scope rules: if an enumeration is declared inside a function, its constants won't be visible outside the function.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="q06f" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    CLUBS</span><span class="pun">,</span></code></li><li class="L2"><code class="language-C"><span class="pln">    DIAMONDS</span><span class="pun">,</span></code></li><li class="L3"><code class="language-C"><span class="pln">    HEARTS</span><span class="pun">,</span></code></li><li class="L4"><code class="language-C"><span class="pln">    SPADE</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span><span class="pln">s1</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="sn3i">
<li>Enumeration Tags and Type Names <br>
<ul><li>ther are two ways to name an enumeration: by declaring a tag or by using typedef to create a genuine type name.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="01yy" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> suit </span><span class="pun">{</span><span class="pln">CLUBS</span><span class="pun">,</span><span class="pln"> DIAMONDS</span><span class="pun">,</span><span class="pln"> HEARTS</span><span class="pun">,</span><span class="pln"> SPADES</span><span class="pun">};</span></code></li><li class="L1"><code class="language-C"><span class="kwd">enum</span><span class="pln"> suit s1</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">;</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="9nk7" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">enum</span><span class="pln"> </span><span class="pun">{</span><span class="pln">CLUBS</span><span class="pun">,</span><span class="pln"> DIAMONDS</span><span class="pun">,</span><span class="pln"> HEARTS</span><span class="pun">,</span><span class="pln"> SPADES</span><span class="pun">}</span><span class="pln"> </span><span class="typ">Suit</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="typ">Suit</span><span class="pln"> s1</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="6dba">
<li>Enumerations as Inegers <br>
<ul><li>C actually treats enumeration variables and constants as integers, and by default the compiler assigns the integers 0,1,2, ... to the constants in a particular enumeration. <br>
<ul><li>But we are free to choose different values for enumeration constants if we like.</li>
<li>It's even legal for two or more enumeration oncstants to have the same value.</li></ul></li>
<li>When no value is specified for an enumeration constant, its value is one greater than the value of the previous constant. (The first enumeration constant has the value 0 by defaut.)</li>
<li>Since enumeration values are nothing by thinly disguised integers, C allows us to mix them with ordinary integers(but is dangerous)</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="pjdq" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> suit </span><span class="pun">{</span><span class="pln">CLUBS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> DIAMONDS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> HEARTS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> SPADES </span><span class="pun">=</span><span class="pln"> </span><span class="lit">4</span><span class="pun">};</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="pln">i </span><span class="pun">=</span><span class="pln"> DIAMONDS</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">s</span><span class="pun">++;</span></code></li><li class="L5"><code class="language-C"><span class="pln">i </span><span class="pun">=</span><span class="pln"> s </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="7x7l">
<li>Using Enumerations to Declare Tag Fields</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="8flr" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">enum</span><span class="pln"> </span><span class="pun">{</span><span class="pln">INT_KIND</span><span class="pun">,</span><span class="pln"> DOUBLE_KIND</span><span class="pun">}</span><span class="pln"> kind</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">union</span><span class="pun">{</span></code></li><li class="L3"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">        </span><span class="kwd">double</span><span class="pln"> d</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln"> u</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span><span class="typ">Number</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="udqk">
<li>Use the Values of an Enumerated Type as Subscripts</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="oogf" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> weekdays </span><span class="pun">{</span><span class="pln">MONDAY</span><span class="pun">,</span><span class="pln"> TUESDAY</span><span class="pun">,</span><span class="pln"> WEDNESDAY</span><span class="pun">,</span><span class="pln"> THURSDAY</span><span class="pun">,</span><span class="pln"> FRIDAY</span><span class="pun">};</span></code></li><li class="L1"><code class="language-C"><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">daily_specials</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">MONDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="str">"beef ravioli"</span><span class="pun">,</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">TUESDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"BLTs"</span><span class="pun">,</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">WEDNESDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Pizza"</span><span class="pun">,</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">THURSDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Chicken fajitas"</span><span class="pun">,</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">FRIDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Macaroni and cheese"</span></code></li><li class="L7"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="lsnd" id="17-advanced-uses-of-pointers">17. Advanced Uses of Pointers</h2><div class="md-section-divider"></div><h3 data-anchor-id="nl4r" id="171-dynamic-storage-allocation">17.1 Dynamic Storage Allocation</h3><ul data-anchor-id="9o6r">
<li>Memory Allocation Functions <br>
<ul><li><strong>Dynamic storage allocation</strong> refers to the ability to allocate storage during program execution. <br>
<ul><li>Using dynamic storage allocation, we can design data structures that grow and shrink as needed.</li></ul></li>
<li>Functions <br>
<ul><li><code>malloc</code> - Allocates a block of memory but doesn't initialize it.</li>
<li><code>calloc</code> - Allocates a block of memory and clears it.</li>
<li><code>realloc</code> - Resizes a previously allocated block of memory.</li></ul></li>
<li>void type <br>
<ul><li>When we call a memory allocation function to request a block of memory, the function doesn't know what type of data we are planning to store in the block, so it returns a value of type <code>void *</code>.</li>
<li>A <code>void *</code> value is a generic pointer - essentially, just a memory address.</li></ul></li></ul></li>
<li>Null Pointers <br>
<ul><li>When a memory allocation function can't locate a block of memory large enough to satisfy our request, the function will return a <strong>null pointer</strong>, represented by a macro named NULL.</li>
<li>In C, pointers test true or false in the ame way as numbers. All non-null pointers test true; only null pointers are false.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ubdb" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//use example 1</span></code></li><li class="L1"><code class="language-C"><span class="kwd">if</span><span class="pun">(</span><span class="pln">p </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="lit">10000</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="com">/*Allocateion failed; take appropriate action*/</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="nltb" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">if</span><span class="pun">(</span><span class="pln">p </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">)...</span></code></li><li class="L1"><code class="language-C"><span class="kwd">if</span><span class="pun">(!</span><span class="pln">p</span><span class="pun">)</span><span class="pln"> </span><span class="pun">...</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="kvng" id="172-dynamically-allocated-strings">17.2 Dynamically Allocated Strings</h3><ul data-anchor-id="hpq9">
<li>Using <code>malloc</code> to Allocate Memory for a String <br>
<ul><li>Functionality <br>
<ul><li>Prototype: <code>void *malloc(size_t size);</code></li>
<li>malloc allocates a block of <code>size</code> bytes and return a pointer to it.  <br>
<ul><li><code>size</code> has type <code>size_t</code>, an unsigned integer type defined in the C library.</li>
<li>In c, a char value requires exactly one byte of stoage - <code>sizeof(char)</code> is 1.</li></ul></li></ul></li>
<li>Example</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="kf4k" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*)</span><span class="pln"> malloc </span><span class="pun">(</span><span class="pln">n</span><span class="pun">+</span><span class="lit">1</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pln">strcpy</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span><span class="pln"> </span><span class="str">"abc"</span><span class="pun">);</span></code></li><li class="L2"><code class="language-C"><span class="com">//the first four characters in the array will now be a, b, c, and \0</span></code></li></ol></pre><ul data-anchor-id="o46u">
<li>Using Dynamic Storage Allocation in String Functions</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="rwac" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">concat </span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">s2</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">result</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    result </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">s1</span><span class="pun">)+</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">s2</span><span class="pun">)+</span><span class="lit">1</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">result </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"Error: malloc failed in concat\n"</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">exit</span><span class="pun">(</span><span class="pln">EXIT_FAILURE</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C"><span class="pln">    strcpy</span><span class="pun">(</span><span class="pln">result</span><span class="pun">,</span><span class="pln"> s1</span><span class="pun">);</span></code></li><li class="L9"><code class="language-C"><span class="pln">    strcat</span><span class="pun">(</span><span class="pln">result</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">);</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="hjhx" id="173-dynamically-alloated-arrays">17.3 Dynamically Alloated Arrays</h3><ul data-anchor-id="leal">
<li>Using <code>malloc</code> to Allocate Storage for an Array <br>
<ul><li>The primary difference in the allocation of storage for an array from that of a string is that the elements of an arbitrary array won't necessarily be one byte long, so we need to use the <code>sizeof()</code> operator to calcuclate the amount of space required.</li>
<li>Once the variable points to a dynamically allocated block of memory, we can ignore the fact that that variable is a pointer and use it instead as an array name.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="clef" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">int</span><span class="pln"> </span><span class="pun">*</span><span class="pln">a</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">a </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="pln">n</span><span class="pun">*</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">));</span></code></li><li class="L2"><code class="language-C"><span class="pln">a</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="kcxw">
<li>The <code>calloc</code> Function <br>
<ul><li>Functionality <br>
<ul><li>Prototype: <code>void *calloc(size_t nmemb, size_t size);</code></li>
<li><code>calloc</code> allocates space for an array with <code>nmemb</code> elements, each of which is <code>size</code> bytes long;</li>
<li>It returns a null pointer if the requested space isn't available.</li>
<li>After allocating the memory, <code>calloc</code> initializes it by setting all bits to 0.</li></ul></li>
<li>Example</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="jvn7" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> point </span><span class="pun">{</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">;}</span><span class="pln"> </span><span class="pun">*</span><span class="pln">p</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">p </span><span class="pun">=</span><span class="pln"> calloc</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> point</span><span class="pun">));</span></code></li></ol></pre><ul data-anchor-id="ooz9">
<li>The <code>realloc</code> Function <br>
<ul><li>The <code>realloc</code> function can resize the array to better suit our needs.</li>
<li>Function <br>
<ul><li>Prototype: <code>void *realloc(void *ptr, size)&lt;/li&gt; <br>
&lt;li&gt;Rules <br>
&lt;ul&gt;&lt;li&gt;When it expands a memory block,</code>realloc<code>doesn't initialize the bytes that are added to the block.&lt;/li&gt; <br>
&lt;li&gt;If</code>realloc<code>can't enlarge the memory block as requested, it returns a null pointer; the data in the old memory block is unchanged.&lt;/li&gt; <br>
&lt;li&gt;If</code>realloc<code>is called with 0 as its second argument, it frees the memory block.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; <br>
&lt;li&gt;Once</code>realloc<code>has returned, be sure to update all pointers to the memory block, since it's possible that</code>realloc` has moved the block elsewhere.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="174-deallocating-storage">17.4 Deallocating Storage</h3>

<ul>
<li>Definitions <br>
<ul><li>A block of memory that's no longer accessible to a program is said to be <strong>garbage</strong>.</li>
<li>A program that leaves garbage behind has a <strong>memory leak</strong>.</li>
<li>Each C program is responsible for recycling its own garbage by calling the <code>free</code> function to release unneeded memory.</li></ul></li>
<li>The <code>free</code> Function <br>
<ul><li>Prototype: <code>void free(void *ptr);</code></li>
<li>callign <code>free</code> releases the block of memory that <code>p</code> points to, so this will be available for reuse in subsequent calls of malloc or other memory allocation functions.</li></ul></li>
<li>The "Dangling Pointer" Problem <br>
<ul><li>The <strong>dangling pointer</strong> problem refers to the fact that the call <code>free(p)</code> deallocates the memory block that p points to, but doesn't change p itself.</li>
<li>If we forget that p no longer points to a valid memory block, chaos may ensue.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="175-linked-lists">17.5 Linked Lists</h3>

<ul>
<li>Introduction <br>
<ul><li>A <strong>linked list</strong> consists of a chain of structures (called <strong>nodes</strong>), with each node containing a pointer to the next node in the chain.</li>
<li>The last node in the list contains a null pointer.</li></ul></li>
<li>Declaring a Node Type <br>
<ul><li>In the definition of node (below), we used <code>struct node</code>. <br>
<ul><li>This is because when a structure has a member that points to the same kind of structure, we are required to use a structure.</li></ul></li>
<li>After declaring a node, we always need a pointer for the first node in the linked list.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> value</span><span class="pun">;</span><span class="pln">          </span><span class="com">/* data stored in the node */</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="kwd">next</span><span class="pun">;</span><span class="pln">  </span><span class="com">/* pointer to the next node */</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">first </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li></ol></pre>

<ul>
<li>Creating a Node <br>
<ul><li>Three Steps <br>
<ul><li>Allocate memory for the node</li>
<li>Store data in the node</li>
<li>Insert the node into the list</li></ul></li>
<li>Codes</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">new_node </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">));</span><span class="pln"> </span><span class="com">// allocate memory</span></code></li><li class="L1"><code class="language-C"><span class="pun">(*</span><span class="pln"> new_node</span><span class="pun">).</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span><span class="pln"> </span><span class="com">//store data</span></code></li><li class="L2"><code class="language-C"><span class="com">//or</span></code></li><li class="L3"><code class="language-C"><span class="pln">new_node</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span></code></li></ol></pre>

<ul>
<li>Inserting a Node at the Beginning of a Linked List</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">new_node</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> first</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">first </span><span class="pun">=</span><span class="pln"> new_node</span><span class="pun">;</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">add_to_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">new_node</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    new_node </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">));</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">new_node </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"Error: malloc failed in add_to_list\n"</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">exit</span><span class="pun">(</span><span class="pln">EXIT_FAILURE</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C"><span class="pln">    new_node</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    new_node</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> new_node</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="com">//to use the method</span></code></li><li class="L5"><code class="language-C"><span class="pln">first </span><span class="pun">=</span><span class="pln"> add_to_list</span><span class="pun">(</span><span class="pln">first</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="com">//to create linked list</span></code></li><li class="L8"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">read_numbers</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">){</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">first </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Enter a series of integers (0 to terminate): "</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(;;){</span></code></li><li class="L4"><code class="language-C"><span class="pln">        scanf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,&amp;</span><span class="pln">n</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n</span><span class="pun">==</span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L6"><code class="language-C"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> first</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pln">        first </span><span class="pun">=</span><span class="pln"> add_to_list</span><span class="pun">(</span><span class="pln">first</span><span class="pun">,</span><span class="pln">n</span><span class="pun">);</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Searching a Linked List</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">search_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">p</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">p </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">;</span><span class="pln"> p </span><span class="pun">!=</span><span class="pln"> NULL</span><span class="pun">;</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">){</span></code></li><li class="L4"><code class="language-C"><span class="pln">        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">p</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="com">//or</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">search_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(;</span><span class="pln">list </span><span class="pun">!=</span><span class="pln">NULL </span><span class="pun">&amp;&amp;</span><span class="pln"> list </span><span class="pun">-&gt;</span><span class="pln">value</span><span class="pun">!=</span><span class="pln">n</span><span class="pun">;</span><span class="pln">list</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> list</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Deleting a Node from a Linked List <br>
<ul><li>Three Steps <br>
<ul><li>Locate the node to be deleted.</li>
<li>Alter the previous node so that it "bypasses" the deleted node.</li>
<li>Call <code>free</code> to reclaim the space occupied by the deleted node.</li></ul></li>
<li>Code</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">delete_from_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">cur</span><span class="pun">,</span><span class="pln"> </span><span class="pun">*</span><span class="pln">prev</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">cur </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">,</span><span class="pln"> prev </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">        cur </span><span class="pun">!=</span><span class="pln"> NULL </span><span class="pun">&amp;&amp;</span><span class="pln"> cur</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">!=</span><span class="pln">n</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">        prev </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">,</span><span class="pln"> cur </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">-&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">cur </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L8"><code class="language-C"><span class="pln">        retun list</span><span class="pun">;</span><span class="pln">         </span><span class="com">// n was not found</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">prev </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        list </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span><span class="pln">  </span><span class="com">// n is in the first node</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="kwd">else</span><span class="pun">{</span></code></li><li class="L4"><code class="language-C"><span class="pln">        prev</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"> </span><span class="com">// n is in some other node</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> list</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<h3 id="176-pointers-to-pointers">17.6 Pointers to Pointers</h3>

<ul>
<li>A pointer to a pointer is a form of multiple indirection, or a chain of pointers. </li>
<li>Normally, a pointer contains the address of a variable.  <br>
<ul><li>When we define a pointer to a pointer, the first pointer contains the address of the second pointer, which points to the location that contains the actual value as shown below.</li>
<li><img src="https://www.tutorialspoint.com/cprogramming/images/pointer_to_pointer.jpg" alt="pointers to pointers" title=""></li></ul></li>
<li><code>int **var;</code></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="177-pointers-to-functions">17.7 Pointers to Functions</h3>

<ul>
<li>Introduction <br>
<ul><li>Definition <br>
<ul><li>In C, like normal data pointers (int *, char *, etc), we can have pointers to functions. </li></ul></li>
<li>Rules <br>
<ul><li>Unlike normal pointers, a function pointer points to code, not data. Typically a function pointer stores the start of executable code.</li>
<li>Unlike normal pointers, we do not allocate de-allocate memory using function pointers.</li>
<li>A function’s name can also be used to get functions’ address. (so we can emit the address operator)</li>
<li>Like normal pointers, we can have an array of function pointers</li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"> </span></code></li><li class="L1"><code class="language-C"><span class="kwd">void</span><span class="pln"> add</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L2"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L3"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Addition is %d\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">+</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li><li class="L5"><code class="language-C"><span class="kwd">void</span><span class="pln"> subtract</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L6"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L7"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Subtraction is %d\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">-</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li><li class="L9"><code class="language-C"><span class="kwd">void</span><span class="pln"> multiply</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L0"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L1"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Multiplication is %d\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">*</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L2"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span></code></li><li class="L5"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="com">// fun_ptr_arr is an array of function pointers </span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">fun_ptr_arr</span><span class="pun">[])(</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">add</span><span class="pun">,</span><span class="pln"> subtract</span><span class="pun">,</span><span class="pln"> multiply</span><span class="pun">};</span><span class="pln"> </span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> ch</span><span class="pun">,</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">15</span><span class="pun">,</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Enter Choice: 0 for add, 1 for subtract and 2 "</span></code></li><li class="L1"><code class="language-C"><span class="pln">            </span><span class="str">"for multiply\n"</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L2"><code class="language-C"><span class="pln">    scanf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">ch</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ch </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="pun">(*</span><span class="pln">fun_ptr_arr</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">])(</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li></ol></pre>

<ul>
<li>The <code>qsort</code> Function</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="kwd">int</span><span class="pln"> compare</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">b</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(*(</span><span class="kwd">int</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">a </span><span class="pun">-</span><span class="pln"> </span><span class="pun">*(</span><span class="kwd">int</span><span class="pun">*)</span><span class="pln">b</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(){</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> arr</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">10</span><span class="pun">,</span><span class="lit">5</span><span class="pun">,</span><span class="lit">15</span><span class="pun">,</span><span class="lit">12</span><span class="pun">,</span><span class="lit">90</span><span class="pun">,</span><span class="lit">80</span><span class="pun">};</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">)/</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="pln">    qsort</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">),</span><span class="pln"> compare</span><span class="pun">);</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln">i</span><span class="pun">++){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Other Uses of Function Pointers</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">void</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">file_cmd</span><span class="pun">[])(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">new_cmd</span><span class="pun">,</span></code></li><li class="L1"><code class="language-C"><span class="pln">                            open_cmd</span><span class="pun">,</span></code></li><li class="L2"><code class="language-C"><span class="pln">                            close_cmd</span><span class="pun">,</span></code></li><li class="L3"><code class="language-C"><span class="pln">                            close_all_cmd</span><span class="pun">};</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<h3 id="178-restricted-pointers">17.8 Restricted Pointers</h3>

<ul>
<li>Code <br>
<ul><li><code>int * restrict p;</code></li></ul></li>
<li>Definition <br>
<ul><li>a pointer that's been declared using <code>restrict</code> is called a <strong>restected pointer</strong></li>
<li>The intent is that if p points to an object that is later modified, then that object is not accessed in any way other than through p.</li></ul></li>
<li>Advantage <br>
<ul><li>restrict provides information to the compiler that may enable it to produce more efficient code - a process known as optimization. </li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="179-flexible-array-members">17.9 Flexible Array Members</h3>

<ul>
<li>We can store the length of the string with the string's characters (but with no null character).</li>
<li>A structure that contains a 1lexible array member is an <strong>incomplete type</strong>.  <br>
<ul><li>An incomplete type is missing pan of the information needed to determine how much <br>
memory it requires. </li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> vstring</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> len</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> chars</span><span class="pun">[</span><span class="lit">1</span></code></li><li class="L3"><code class="language-C"><span class="pln">    A structure that contains a </span><span class="lit">1lexible</span><span class="pln"> array member </span><span class="kwd">is</span><span class="pln"> an incomplete type</span><span class="pun">.</span><span class="pln"> </span><span class="typ">An</span></code></li><li class="L4"><code class="language-C"><span class="pln">incomplete type </span><span class="kwd">is</span><span class="pln"> missing pan of the information needed to determine how much</span></code></li><li class="L5"><code class="language-C"><span class="pln">memory it requires</span><span class="pun">.</span><span class="pln"> </span><span class="pun">];</span></code></li><li class="L6"><code class="language-C"><span class="pun">};</span></code></li><li class="L7"><code class="language-C"><span class="com">//The length of the char array isn't determined </span></code></li><li class="L8"><code class="language-C"><span class="com">//until memory is allocated for a vstring structure.</span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> vstring </span><span class="pun">*</span><span class="pln">str </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> vstring</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pln">str</span><span class="pun">-&gt;</span><span class="pln">len </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span></code></li></ol></pre>

<hr>

<div class="md-section-divider"></div>

<h2 id="18-declarations">18. Declarations</h2>

<div class="md-section-divider"></div>

<h3 id="181-declaration-syntax">18.1 Declaration Syntax</h3>

<ul>
<li>Declarations furnish information to the compiler about the meaning of identifiers.</li>
<li>In general, a delcaration has the following appearance: <code>declaration-specifiers delcarators;</code> <br>
<ul><li><strong>Declaration specifiers</strong> describe the properties of the variables or functions being declared.</li>
<li><strong>Declarators</strong> give their names and many provie additional information about their properties.</li></ul></li>
<li>Three Categories of Declaration Specifiers <br>
<ul><li><strong>Storage class</strong> <br>
<ul><li>There are four storage classes: <code>auto</code>, <code>static</code>, <code>extern</code>, and <code>register</code>.</li>
<li>At most one strage class appear in a delcaration.</li>
<li>If present, it should come first.</li></ul></li>
<li><strong>Type qualifiers</strong> <br>
<ul><li>There are three qualifiers: <code>const</code>, <code>volative</code>, and <code>restrict</code>.</li>
<li>A declaration may contain zero or more type quanlifers.</li></ul></li>
<li><strong>Type specifiers</strong> <br>
<ul><li>The keywords <code>void</code>, <code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>signed</code>, and <code>unsigned</code> are all type specifiers. The order in which they appear doesn't matter.</li>
<li>Type specifiers also include specifications of structures, unions, and enumerations.</li>
<li>Type names created using <code>typedef</code> are specifiers as well.</li></ul></li>
<li><strong>Function specifier</strong> <br>
<ul><li>Function specifier is used only in function declarations.</li>
<li>This category has just one member, the keyword <code>inline</code>.</li></ul></li></ul></li>
<li>Declarators <br>
<ul><li>Declarators include <strong>identifiers</strong> (name of simple variables), identifiers followed by [] (array names), identifiers preceded by * (pointer names), and identifiers followed by () (function names).</li>
<li>Declarators are separated by commas.</li>
<li>A declarator that represents a variable may be followed by an initializer.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="182-storage-classes">18.2 Storage Classes</h3>

<ul>
<li>Properties of Variables <br>
<ul><li>Three Types of Properties <br>
<ul><li><strong>storage duration</strong> <br>
<ul><li>the storage duration of a variable determines when memory is set aside for the variable and when that memory is released.</li>
<li>Storage for a variable with <strong>automatic storage duration</strong> is allocated when the surrounding block is executed, and is deallocated when the block terminates.</li>
<li>A variable with <strong>static storage duration</strong> stays at the same storage location as long as the program is running, allowing it to retain its value indefinitely.</li></ul></li>
<li><strong>scope</strong> <br>
<ul><li>The scope of a variable is the portion of the program text in which the variable can be referenced.</li>
<li>A variable can have either <strong>block scope</strong> (vbisible from its point of declaration to the end of the enclosing block), or <strong>file scope</strong> (visible from its point of declaration to the end of the enclosing file).</li></ul></li>
<li><strong>linkage</strong> <br>
<ul><li>The linkage of a variable determines the extent to which it can be shared by different pats of a program.</li>
<li>A variable with <strong>external linkage</strong> may be shared by several (or all) files in a program.</li>
<li>A variable with <strong>internal linkage</strong> is restricted to a single file, but may be shared by the functions in that file. (If a variable with the same name appears in another file, it's treated as a different variable.)</li>
<li>A variable with <strong>no linkage</strong> belongs to a single function and can't be shared at all. </li></ul></li></ul></li>
<li>Default Propeties  <br>
<ul><li>Variables declared inside a block (including a function body) have automatic storage duration, block scope, and no linkage. </li>
<li>Variables declared outside any block, at the outermost level of a program, have static storage duration, flie scope, and external linkage. </li></ul></li></ul></li>
<li>The <code>audo</code> Storage Class <br>
<ul><li>The <code>auto</code> storage class is legal only for variables that belong to a block. </li>
<li>An <code>auto</code> variable has automatic storage duration (not surprisingly). block scope. and no linkage.</li>
<li>The <code>auto</code> storage class is almost never specified explicilly. since it's the default for variables declared inside a block. </li></ul></li>
<li>The <code>static</code> Storage Class <br>
<ul><li>The <code>static</code> storage class can be used with all variable regardless of where they're declared. but it has a different effect on a variable dedared outside a block than it does on a variable declared inside a block.  </li>
<li>When used outside a block, the word <code>static</code> specifies that a variable has internal linkage. </li>
<li>When used inside a block. static changes the variable storage duration from amomaric to static.</li>
<li>The use of <code>static</code> can help implement a tecnique known as information hiding.</li></ul></li>
<li>The <code>extern</code> Storage Class <br>
<ul><li>The extern storage class enables several source files to share the same variable. </li>
<li>A variable in an extern declaration always has static storage duration. </li>
<li>The scope of the variable depends on the declaration's placement.  <br>
<ul><li>If the declaration is inside a block, the variable has block scope; otherwise, it has file scope. </li></ul></li>
<li>If the variable was declared static earlier in the file (outside of any function deiinition). then it has internal linkage. </li>
<li>Otherwise (the normal case), the variable has external linkage. </li></ul></li>
<li>The <code>register</code> Storage Class <br>
<ul><li>Using the ·register· storage class in the declaration of a variable asks the compiler to store the variable in a register instead of keeping it in main memory like other variables. <br>
<ul><li>A <strong>register</strong> is a storage area located in a computer's CPU. Data stored in a register can be accessed and updated faster than data stored in ordinary memory.</li>
<li>The register storage class is legal only for variables declared in a block.  <br>
<ul><li>A register variable has the same storage duration, scope. and linkage as an auto variable. </li></ul></li>
<li><code>register</code> is best used for variables that are accessed and/or updated frequently.</li></ul></li></ul></li>
<li>The Storage Class of a Function <br>
<ul><li>Function declarations (and definitions), like variable declarations, may include a storage class, but the only options are <code>extern</code> and <code>static</code>.  <br>
<ul><li>The word <code>extern</code> at the beginning of a function declaration specifies that the function has external linkage, allowing it to be called from other files. </li>
<li><code>static</code> indicates internal linkage, limiting use of the function's name to the file in which it's defined. </li>
<li>If no storage class is specified. the function is assumed to have external linkage.</li></ul></li>
<li>Declaring function to be extern is like declaring variables to be auto - it serves no purpose.</li>
<li>Declaring functions to be <code>static</code> is quite useful: <br>
<ul><li><strong>Easier maintenance **: Declaring a function f co be static guarantees that f isn't visible outside the file in which its definition appears. As a result, someone modifying the program later knows that changes to f won't affect functions in other files.</strong></li><strong>
</strong><li><strong>**Reduced "name space pollution"</strong>: Since functions declared static have internal linkage, their names can be reused in other files. </li></ul></li></ul></li>
<li>Function Parameters <br>
<ul><li>Function parameters have the same properties as auto variables: automatic storage duration, block scope, and no linkage. The only storage class that can be specified for parameters is register. </li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="183-type-qualifiers">18.3 Type Qualifiers</h3>

<ul>
<li>There are two types qualifiers: <code>const</code> and <code>volative</code>.</li>
<li><code>const</code> is used to delcare objects that resemble variables but are "read-only": a program may access the value of a const object, but can't change it.</li>
<li>Advantages of Using <code>const</code> <br>
<ul><li>It's a form of documentation: it ale1ts anyone reading the program to the read only nature of the object.</li>
<li>The compiler can check that the program doesn't inadvertently attempt to change the value of the object. </li>
<li>When programs are written for certain types of applications (embedded systems, in particular), the compiler can use the word const to identify data to be stored in ROM (read-only memory).</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="184-declarators">18.4 Declarators</h3>

<ul>
<li>Introduction <br>
<ul><li>A declarator consistc; of an idenlilier (the name of the variable or function being declared), possibly preceded by the * symbol or followed by [] or ( ) . </li>
<li>A declarator that begins with * represents a pointer.</li>
<li>A declarator that ends with [] represents an array. <br>
<ul><li>The brackets may be left empty if the array is a parameter. if it has an initializer.</li>
<li>C99 provides two additional options for what goes between the brackets in the declaration of an array paramerer.  <br>
<ul><li>One option is the keyword static. followed by an expression that pecifies the array's minimum length.  </li>
<li>The other is the * symbol, which can be used in a function protytype to indicate a variable-length array argument.</li></ul></li></ul></li>
<li>A declarator that ends with () represents a function. <br>
or if its storage class is extern</li></ul></li>
<li>Deciphering Complex Declarations <br>
<ul><li>Always read declarators from the inside out.</li>
<li>When there's a choice, always favor [] and () over <em>.</em></li></ul></li>
<li>Using Type Definitions to Simplify Declarations <br>
<ul><li>Some programmers use type definitions to help simplify complex declarations. </li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="185-initializers">18.5 Initializers</h3>

<ul>
<li><p>Introduction</p>

<ul><li>To initialize a variable. we write the = symbol after lts declarator, then follow lhat with an inilializer. </li>
<li>Don't confuse the = symbol in a declaration with the assignment operator, initialization isn't the same as assignment.</li>
<li>The initialize for a simple variable is au expression of the same type as the variable. <br>
<ul><li>If the type don't match, C converts the initializer using the same rules as for assignment - convert it to the same type.</li>
<li>The initializer for a pointer variable must be a pointer expression of the same type as lhe variable or of type void*.</li>
<li>The initializet for an array, structure, or union is usually a series of values enclosed in braces.</li></ul></li>
<li>Other Rules <br>
<ul><li>An initializer for a variable with static storage duration must be constant.</li>
<li>If a variable has automatic storage duration, its initializer need not be constant.</li>
<li>A brace-enclosed iuitializer for an array. structure, or union must contain only constant expressions, never variables or function calls.</li>
<li>The initializer for an automatic structure or union can be another stnJcture or union</li></ul></li></ul></li>
<li><p>Uninitialized Variables</p>

<ul><li>Variables with alllomatic storage duration have no default initial value.  <br>
<ul><li>The initial value of an automatic variable can't be predicted and may be different each time the variable comes into existence. </li></ul></li>
<li>Variables with sraric storage duration have the value Lero by default.  <br>
<ul><li>Unlike memory allocated by calloc. which is simply set to zero bit, a static variable is correctly initialiL.ed based on its type: integer variables are initialized to 0, floating variables are initialized to 0.0, and pointer variables contain a null pointer. </li>
*</ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="186-inline-functions">18.6 Inline Functions</h3>

<ul>
<li>Introduction <br>
<ul><li>The word 'inline" suggestsan implementation strategy in which the compiler replaces each call of the function by the machine instructions for the function.</li>
<li>Declaring a function to be inline doesn't force th compiler to inline the function, but suggest to do so.</li></ul></li>
</ul>

<hr>

<div class="md-section-divider"></div>

<h2 id="19-program-design">19. Program Design</h2>

<div class="md-section-divider"></div>

<h3 id="191-modules">19.1 Modules</h3>

<ul>
<li>Introduction <br>
<ul><li>Definitions <br>
<ul><li>A <strong>module</strong> is a collection of services, some of which are made available to other parts of the program (the <strong>client</strong>).</li>
<li>Each module has an <strong>interface</strong> that describes the avaialble services, wich is a header file containing prototypes for  the functions that will be mad available to clients.</li>
<li>The details of the module, including the source code for the services themselves, are stored in the module's <strong>implementation</strong></li></ul></li>
<li>Advantages of Dividing a Program into Modules <br>
<ul><li>Abstraction: we know what they do, but we don't worry about the details of how they do it.</li>
<li>Reusability: a module that provides services is potentially reusable in other programs.</li>
<li>Maintainability: a small budy will usually affect only a single module implementation, making the bug easier to locate and fix.</li></ul></li></ul></li>
<li>Properties of Well-Designed Modules <br>
<ul><li>High cohesion: the elements of each module should be closely related to one another, which makes the modules easier to use and the entire program easier to understand.</li>
<li>Low coupling: modules should be as independent of each other as possible.</li></ul></li>
<li>Types of Modules <br>
<ul><li>A <strong>data pool</strong> is a collection of related varaibles and/or constants, which is often just a header file that contains all the constants (but usually not variables)</li>
<li>A <strong>library</strong> is a collection of related functions.</li>
<li>An <strong>abstract object</strong> is a collection of functions that operate on a hidden data structure.</li>
<li>An <strong>abstract data type (ADT)</strong> is a type whose representation is hidden.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="192-information-hiding">19.2 Information Hiding</h3>

<ul>
<li>Definition <br>
<ul><li>Deliberately concealing information from the clinets of a module is known as <strong>information hiding</strong></li></ul></li>
<li>Application <br>
<ul><li>Declaring a variable file scope to be <code>static</code> gives it internal linkage, thus preventing it from being accessed from other files, including cleints of the module.</li></ul></li>
<li>Benefits <br>
<ul><li>Security: if clinets don't know how the stack is stored, they won't be able to corrupt it by tampering with its internal workings.</li>
<li>Flexibility: making changes to a module's internal working won't be difficult.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="193-abstract-data-types">19.3 Abstract Data Types</h3>

<ul>
<li>Introduction <br>
<ul><li>A module that serves as an abstract object has a senous disadvantage: there's no way to have multiple instances of the object.</li>
<li>To accomplish this, we will need to create a new type by adding a structure definition in the header file, and adding a pointer to that structure in every function.</li></ul></li>
<li>Encapsulation <br>
<ul><li>Problem <br>
<ul><li>However, making the object a structure will reveal what the type really is, so nothing can prevent clients from using that structure.</li></ul></li>
<li>Solution <br>
<ul><li>The only tool that C gives us for encapsulation is <strong>incomplete type</strong>, which refers to types that describe objects but lack information needed to detrmine their sizes.</li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> t</span><span class="pun">;</span><span class="pln">       </span><span class="com">/* incomplete declaration of t */</span></code></li><li class="L1"><code class="language-C"><span class="com">// this just tells that t is a structure </span></code></li><li class="L2"><code class="language-C"><span class="com">//but doesn't describe the members of the structure.</span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="kwd">struct</span><span class="pln"> t s</span><span class="pun">;</span><span class="pln">     </span><span class="com">/* wrong */</span></code></li><li class="L5"><code class="language-C"><span class="com">//it can't be used to declare a variable,</span></code></li><li class="L6"><code class="language-C"><span class="com">//as the intent is that an incomplete type will be copleted elsewhere in the program</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> t </span><span class="pun">*</span><span class="pln">T</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="com">//however, it's legal to define a pointer type that references an incomplete type.</span></code></li><li class="L0"><code class="language-C"><span class="com">//the size of the pointer doesn't depends on what it points to,</span></code></li><li class="L1"><code class="language-C"><span class="com">//which explains why C allows this behaviour.</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<h3 id="194-a-stack-abstract-data-type">19.4 A Stack Abstract Data Type</h3>

<ul>
<li>Definiing the Interface for the Stack ADT</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//stackADT.h  version1</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="com">#ifndef</span><span class="pln"> STACKADT_H</span></code></li><li class="L3"><code class="language-C"><span class="com">#define</span><span class="pln"> STACKADT_H</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdbool.h&gt;</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> stack_type </span><span class="pun">*</span><span class="typ">Stack</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="typ">Stack</span><span class="pln"> create</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">);</span></code></li><li class="L0"><code class="language-C"><span class="kwd">void</span><span class="pln"> destroy</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="kwd">void</span><span class="pln"> make_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L2"><code class="language-C"><span class="kwd">bool</span><span class="pln"> is_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="kwd">bool</span><span class="pln"> is_full</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="kwd">void</span><span class="pln"> push</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="kwd">int</span><span class="pln"> pop</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="com">#endif</span></code></li></ol></pre>

<ul>
<li>Implementing the Stack ADT Using a Fixed-Length Array</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//stackADT.c</span></code></li><li class="L1"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></code></li><li class="L2"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdlib.h&gt;</span></code></li><li class="L3"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">"stackADT1.h"</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="com">#define</span><span class="pln"> STACK_SIZE </span><span class="lit">100</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="kwd">struct</span><span class="pln"> stack_type</span><span class="pun">{</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> contents</span><span class="pun">[</span><span class="pln">STACK_SIZE</span><span class="pun">];</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> top</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pun">}</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> terminate</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">message</span><span class="pun">){</span></code></li><li class="L3"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"%s\n"</span><span class="pun">,</span><span class="pln"> message</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">exit</span><span class="pun">(</span><span class="pln">EXIT_FAILURE</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="typ">Stack</span><span class="pln"> create</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">){</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="typ">Stack</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> stack_type</span><span class="pun">));</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">s </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L0"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in create: stack could not be created."</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L2"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln"> top </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="kwd">void</span><span class="pln"> destroy</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L7"><code class="language-C"><span class="pln">    free</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="kwd">void</span><span class="pln"> make_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pun">}</span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="kwd">void</span><span class="pln"> make_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="kwd">void</span><span class="pln"> is_full</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">==</span><span class="pln"> STACK_SIZE</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pun">}</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">void</span><span class="pln"> push</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">){</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">is_full</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)){</span></code></li><li class="L4"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in push: stack is full"</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">contents</span><span class="pun">[</span><span class="pln">s</span><span class="pun">-&gt;</span><span class="pln">top</span><span class="pun">++]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pun">}</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="kwd">int</span><span class="pln"> pop</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> a</span><span class="pun">){</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">is_empty</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)){</span></code></li><li class="L1"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in pop: stack is empty"</span><span class="pun">);</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">contents</span><span class="pun">[--</span><span class="pln">s</span><span class="pun">-&gt;</span><span class="pln">top</span><span class="pun">];</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Changing the Item Type in the Stack ADT</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//stackADT2.h  version2</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="com">#ifndef</span><span class="pln"> STACKADT_H</span></code></li><li class="L3"><code class="language-C"><span class="com">#define</span><span class="pln"> STACKADT_H</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdbool.h&gt;</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> </span><span class="typ">Item</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pln"> stack_type </span><span class="pun">*</span><span class="typ">Stack</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="typ">Stack</span><span class="pln"> create</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">);</span></code></li><li class="L2"><code class="language-C"><span class="kwd">void</span><span class="pln"> destroy</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="kwd">void</span><span class="pln"> make_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="kwd">bool</span><span class="pln"> is_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="kwd">bool</span><span class="pln"> is_full</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="kwd">void</span><span class="pln"> push</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Item</span><span class="pln"> i</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C"><span class="typ">Item</span><span class="pln"> pop</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">);</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="com">#endif</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//modification on stack_type</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">struct</span><span class="pln"> stack_type</span><span class="pun">{</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="typ">Item</span><span class="pln"> contents</span><span class="pun">[</span><span class="pln">STACK_SIZE</span><span class="pun">];</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> top</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Implementing the Stack ADT Using a Dynamic Array</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//stackADT.c</span></code></li><li class="L1"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></code></li><li class="L2"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdlib.h&gt;</span></code></li><li class="L3"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">"stackADT2.h"</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="com">#define</span><span class="pln"> STACK_SIZE </span><span class="lit">100</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="kwd">struct</span><span class="pln"> stack_type</span><span class="pun">{</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> </span><span class="pun">*</span><span class="pln">contents</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> top</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> size</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> terminate</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">message</span><span class="pun">){</span></code></li><li class="L4"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"%s\n"</span><span class="pun">,</span><span class="pln"> message</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="kwd">exit</span><span class="pun">(</span><span class="pln">EXIT_FAILURE</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="typ">Stack</span><span class="pln"> create</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> size</span><span class="pun">){</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="typ">Stack</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> stack_type</span><span class="pun">));</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">s </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in create: stack could not be created."</span><span class="pun">);</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L3"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln"> content </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="pln">size </span><span class="pun">*</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="typ">Item</span><span class="pun">));</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">s</span><span class="pun">-&gt;</span><span class="pln">contents </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">        free</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in create: stack could not be created."</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">size </span><span class="pun">=</span><span class="pln"> size</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">void</span><span class="pln"> destroy</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L4"><code class="language-C"><span class="pln">    free</span><span class="pun">(</span><span class="pln">s</span><span class="pun">-&gt;</span><span class="pln">contents</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    free</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="kwd">void</span><span class="pln"> make_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L9"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pun">}</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">void</span><span class="pln"> make_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="kwd">void</span><span class="pln"> is_full</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">==</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">size</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="kwd">void</span><span class="pln"> push</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">is_full</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in push: stack is full"</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">contents</span><span class="pun">[</span><span class="pln">s</span><span class="pun">-&gt;</span><span class="pln">top</span><span class="pun">++]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="kwd">int</span><span class="pln"> pop</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> a</span><span class="pun">){</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">is_empty</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)){</span></code></li><li class="L9"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in pop: stack is empty"</span><span class="pun">);</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">contents</span><span class="pun">[--</span><span class="pln">s</span><span class="pun">-&gt;</span><span class="pln">top</span><span class="pun">];</span></code></li><li class="L2"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Implementing the Stack ADT Using a Linked List</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//stackADT3.c</span></code></li><li class="L1"><code class="language-C"><span class="com">#include</span><span class="str">&lt;stdio.h&gt;</span></code></li><li class="L2"><code class="language-C"><span class="com">#include</span><span class="str">&lt;stlib.h&gt;</span></code></li><li class="L3"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">"stackADT.h"</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">{</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="typ">Item</span><span class="pln"> data</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="kwd">next</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pun">};</span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> stack_type</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">top</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pun">};</span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="kwd">static</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> terminate</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">message</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"%s\n"</span><span class="pun">,</span><span class="pln"> message</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="kwd">exit</span><span class="pun">(</span><span class="pln">EXIT_FAILURE</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C"><span class="pun">}</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="typ">Stack</span><span class="pln"> create</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">){</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="typ">Stack</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> stack_type</span><span class="pun">));</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">s </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in create: stack could not be created."</span><span class="pun">)</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="kwd">void</span><span class="pln"> destroy</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L9"><code class="language-C"><span class="pln">    make_empty</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)</span></code></li><li class="L0"><code class="language-C"><span class="pln">    free</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">void</span><span class="pln"> make_empty</span><span class="pun">(){</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">while</span><span class="pun">(!</span><span class="pln">is_empty</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)){</span></code></li><li class="L5"><code class="language-C"><span class="pln">        pop</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L7"><code class="language-C"><span class="pun">}</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="kwd">bool</span><span class="pln"> is_empty</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">bool</span><span class="pln"> is_full</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="kwd">void</span><span class="pln"> push</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Item</span><span class="pln"> i</span><span class="pun">){</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">new_node </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">));</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">new_node </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L0"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in push: stack is full."</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    new_node</span><span class="pun">-&gt;</span><span class="pln">data </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">    new_node</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> s</span><span class="pun">-&gt;</span><span class="pln">top</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">    s</span><span class="pun">-&gt;</span><span class="pln">top </span><span class="pun">=</span><span class="pln"> new_node</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="typ">Item</span><span class="pln"> pop</span><span class="pun">(</span><span class="typ">Stack</span><span class="pln"> s</span><span class="pun">){</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">old_top</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="typ">Item</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">is_empty</span><span class="pun">(</span><span class="pln">s</span><span class="pun">)){</span></code></li><li class="L3"><code class="language-C"><span class="pln">        terminate</span><span class="pun">(</span><span class="str">"Error in pop</span></code></li><li class="L4"><code class="language-C"><span class="str">    }</span></code></li><li class="L5"><code class="language-C"><span class="str">}</span></code></li><li class="L6"><code class="language-C"></code></li></ol></pre>

<div class="md-section-divider"></div>

<h3 id="195-design-issues-for-abstract-data-types">19.5 Design Issues for Abstract Data Types</h3>

<ul>
<li>Naming Conventions <br>
<ul><li>If we have more than one ADT in a program, name clashes are likely.</li>
<li>Therefore, we'll probabbly need to use function names that incorporate the name of the ADT itself, such as <code>stack_create</code> instead of <code>create</code>. </li></ul></li>
<li>Error Handling <br>
<ul><li>In ADTs we usually deals with errors by displaying an error message and terminating the program, but we might want to provide a way for a program to recover from these errors rather than terminating.</li>
<li>An alternative is to have the <code>push</code> and <code>pop</code> functions return a bool value to indicate whether or not they succeeded (or a NULL pointer for pop).</li>
<li>We should use a parameterized macro named <code>assert</code> that can terminate a program if specified condition isn't satisfied.</li></ul></li>
<li>Generic ADTs <br>
<ul><li>We want an ADT that can accept generic types of elements.</li>
<li>This can partially achieved by using the <code>void *</code> pointer, but this way we can not do some error handling. </li></ul></li>
</ul>

<hr>

<div class="md-section-divider"></div>

<h2 id="20-low-level-programming">20. Low-Level Programming</h2>

<div class="md-section-divider"></div>

<h3 id="201-bitwise-operators">20.1 Bitwise Operators</h3>

<ul>
<li>Bitwise Shift Operators <br>
<ul><li>The bitwise shift operators can transform the binary representation of an integer by shifting its bits to the left or right.</li>
<li><code>&lt;&lt;</code> is left shift, and <code>&gt;&gt;</code> is right shift.</li>
<li>The operands for &lt;&lt; and &gt;&gt; may be of any integer type (including <code>char</code>).</li>
<li>The value of <code>a = i&gt;&gt;j</code> is the result when i is shifted right by j places, and the value will be given to a. <br>
<ul><li>If i is of an unsigned type or if the value of i is nonnegative, zeros are added at the left as needed.</li>
<li>If i is a negative number, the result changes depending on the specific implementation (so should be avoided.)</li></ul></li>
<li>The value of <code>i &lt;&lt;= 2</code> is the result when i is shifted left by 2 places.</li>
<li>The bitwise shift operators have lower precedence than the arithmetic operators. <br>
<ul><li><code>i&lt;&lt;2+1</code> means <code>i&lt;&lt;(2+1)</code></li></ul></li></ul></li>
<li>Bitwise Complement, And, Exclusive Or, and Inclusive Or <br>
<ul><li>Operators <br>
<ul><li><code>~</code> bitwise complement</li>
<li><code>&amp;</code> bitwise and</li>
<li><code>^</code> bitwise exclusive or</li>
<li><code>|</code> bitwise inclusive or</li></ul></li>
<li>The four operators perform Boolean operations on all bits in their operands. <br>
<ul><li>The ~ operator produces the complement of its operand, with zeros replaced by ones and ones replaced by zeros.</li>
<li>The &amp; operator performs a Boolean and operation on all corresponding bits in its two operands.</li>
<li>The ^ and | operators are similar, but ^ produces 0 whenever both operands have a 1 bit, where | produces 1.</li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="202-bit-fields-in-structures">20.2 Bit-Fields in Structures</h3>

<ul>
<li>Introduction <br>
<ul><li>C provides an option to work with bit fields: declarign structures whose members represent bit-fields.</li>
<li>The number after each member indicates its length in bits.</li>
<li>The type of a bit-field must be either int, unsigned int, or signed int, but the preferred way is to use unsigned int or signed int.</li>
<li>Since bit-fields don't have addresses in the usual sense, C doesn't allow us to apply the address operator to a bit field.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> file_date</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> dat</span><span class="pun">:</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> month</span><span class="pun">:</span><span class="pln"> </span><span class="lit">4</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> year</span><span class="pun">:</span><span class="pln"> </span><span class="lit">7</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>How Bit-Fields Are Stored <br>
<ul><li>The rules concerning how the compiler handles bit-fields depend on the notion of "storage units". <br>
<ul><li>The size of a storage unit is implementation-defined: typical values are 8 bits, 16 bits, and 32 bits.</li></ul></li>
<li>C allows us to omit lhe name of any bit-field. Unnamed bit-fields are useful as padding to ensure that other bit fields are properly positioned.  <br>
<ul><li>Another trick that we can ase to control the storage of bit-fields is to specify 0 as the length of an unnamed bit-field: </li>
<li>A 0-length bit-field is a signal to the compiler to align the following bit-field at the beginning of a storage unit. </li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="203-other-low-level-techniques">20.3 Other Low-Level Techniques</h3>

<ul>
<li>Defining Machine-Dependent Types</li>
<li>Using Unions to Provide Multiple Views of Data</li>
<li>Using Pointers as Addresses</li>
<li>The volatile Type Qualifier <br>
<ul><li>On some computers, certain memory locations are "volatile"; the value stored at such a location can change as a program is running, even though the program itself isn't storing new values there.</li>
<li>The <code>volatile</code> type qualifier allows us to inform the compiler if any of the data used in a program is volatile. </li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h2 id="21-the-standard-library">21. The Standard Library</h2>

<div class="md-section-divider"></div>

<h3 id="211-using-the-library">21.1 Using the Library</h3>

<ul>
<li>Restrictions on Names Used in the Library <br>
<ol><li>it can't use the names of macros defined in that header for any other purpose.</li>
<li>librarynames with file scope (<code>typedef</code> names in particular) can't be redefined at the file level.</li>
<li>Identifiers that begin with an underscore followed by an upper-case letter or a second underscore are reserved for use within the library, and programs should never use names of this form for any purpose.</li>
<li>Identifiers that begin with an underscore are reserved for use as identifiers and tags with file scope.</li>
<li>Every identifier with external linkage in the standard library is reserved for use as an identifier with external linkage.</li></ol></li>
<li>Functions Hidden By Macros <br>
<ul><li>The C standard allows the headers to define macros that have the same names as library functions, but protects the programmer by requiring that a true function be available as well. <br>
<ul><li>As a result, its not unusual for a library header to declare a function and define a macro with the same name.</li></ul></li>
<li>Most of the time, we're happy using a macro instead of a true function, becuase it will probabily make our program run faster. <br>
<ul><li>But if we want to minimize the size of the executable code, we can remove a macro definition to gain access to the true function by using the <code>#undef</code> directive.</li>
<li>As an alternative, we can disable invididual uses of a macro by putting paratheses around its name: <code>ch = (getchar)()</code></li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="212-c89-library-overview">21.2 C89 Library Overview</h3>

<ul>
<li><code>&lt;assert.h&gt;</code> Diagnostic: contains only the assert macro, which allows us to insert self-checks into a program. If any check fails, the program terminates.</li>
<li><code>&lt;ctype.h&gt;</code> Chracter Handling: provides functions for classifying chracters and for converting letters from lower to upper case or vice versa.</li>
<li><code>&lt;errno.h&gt;</code> Errors: Provides errno ("error number"). an I value that can be tested after a call of certain library function~ to see if an en·or occurred during the call. </li>
<li><code>&lt;float.h&gt;</code> Chracteristics of Floating Types: Provides macros that describe the characteristics of floating types. including their range and accuracy. </li>
<li><code>&lt;limits.h&gt;</code> Size of Integer Types: Provides macros that describe the characteristics of integer types (including character types), inc1uding their maximum and minimum values. </li>
<li><code>&lt;locale.h&gt;</code> Localization: Provides functions to help a program adapt its behavior to a country or other geographic region. </li>
<li><code>&lt;math.h&gt;</code> Mathematics: Provides common mathematical functions. including trigonometric, hyperbolic, exponential, logarithmic, power, nearest integer, absolute value, and remainder functions. </li>
<li><code>&lt;setjmp.h&gt;</code> Nonlocal Jumps: Provides the setjmp and longjmp runctions. setjmp '·marks" a place inn program; longjump can then be used to return to that place later. </li>
<li><code>&lt;signal.h&gt;</code> Signal Handling: Provides functions that deal with exceptional conditions (signals), including tnterrupts and run-time errors. </li>
<li><code>&lt;stdarg.h&gt;</code> Variable Arguments:Provide~ tools for writing functions that. like printf and scanf, can have a variable number of arguments. </li>
<li><code>&lt;stddef.h&gt;</code> Common Definitions: Provides definitions of frequently used types and macros</li>
<li><code>&lt;stdio.h&gt;</code>Input/Output: Provides a large assortment of input/output functions. including operations on both sequential and random-access files. </li>
<li><code>&lt;stdlb.h&gt;</code> General Utilities:A "catchall" header for functions that don't fit into any of the other headers. </li>
<li><code>&lt;string.h&gt;</code> String Handling: Provides functions that perform string operations, including copying, concatanation, comparison, and searching, as well as functions that operate on arbitrary blocks of memory. </li>
<li><code>&lt;time.h&gt;</code> Date and Time: Provides functions for determining the time (and date), manipulating times, and formatting limes for display. </li>
</ul>

<div class="md-section-divider"></div>

<h3 id="213-c99-library-changes">21.3 C99 Library Changes</h3>

<ul>
<li>Changes <br>
<ul><li>Additional headers</li>
<li>Additional macros and functions in the existign headers</li>
<li>Enhanved versions of existign functions</li></ul></li>
<li>New Headers <br>
<ul><li><code>&lt;complex.h&gt;</code>Complex Arith metic</li>
<li><code>&lt;fenv.h&gt;</code> Floating Point Environment</li>
<li><code>&lt;inttypes.h&gt;</code> Format Conversion of Integer Types</li>
<li><code>&lt;iso646.h&gt;</code>Alternative Spellings</li>
<li><code>&lt;stdbool.h&gt;</code> Boolean Type and Values</li>
<li><code>&lt;stdint.h&gt;</code> Integer Types</li>
<li><code>&lt;tgmath.h&gt;</code>Type-Generic Math</li>
<li><code>&lt;wchar.h&gt;</code>Extended Multibyte and Wide-Character Utilities</li>
<li><code>&lt;wctype.h&gt;</code> Wide-Character Classification and Mapping Utilities</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="214-the-stddefh-header-common-definitions">21.4 The <code>&lt;stddef.h&gt;</code> Header: Common Definitions</h3>

<ul>
<li>Three Types <br>
<ul><li><code>ptrdiff_t</code>: the type of the result when two pointers are subtracted - a signed char</li>
<li><code>size_t</code>: the type returned by the sizeof operator - an unsigned type</li>
<li><code>wchar_t</code>: a type large enough to represent all possible characters in all supported locales</li></ul></li>
<li>Two Macros <br>
<ul><li><code>NULL</code> the null pointer</li>
<li><code>offsetof</code> requires two arguments: a structure type and member-designator (a member of the structure). <br>
<ul><li><code>offsetof</code> computes the number of bytes between the beginning of the structure and the specified member.</li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="215-the-stdboolh-header-c99-boolean-type-and-values">21.5 The <code>&lt;stdbool.h&gt;</code> Header (C99): Boolean Type and Values</h3>

<ul>
<li><p>Four Macros</p>

<ul><li><code>bool</code> defined to be _Bool</li>
<li><code>true</code> defined to be 1</li>
<li><code>false</code> defined to be 0</li>
<li><code>__bool_true_false_are_defined</code> defined to be 1</li></ul>

<hr></li>
</ul>

<div class="md-section-divider"></div>

<h2 id="22-inputoutput">22. Input/Output</h2>

<div class="md-section-divider"></div>

<h3 id="221-streams">22.1 Streams</h3>

<ul>
<li>Definition <br>
<ul><li>In C, the term <strong>stream</strong> means any source of input or any destination for output. </li></ul></li>
<li>File Pointers <br>
<ul><li>Accessing a stream in a C program is done through a file poi1lter, which has type <code>FILE *</code> (the FILE type is declared in ). </li>
<li>Certain streams are represented by file pointers with standard name; we can declare additional file pointers as needed.</li></ul></li>
<li><p>Standard Streams and Redirection</p>

<ul><li> provides three stnadard streams, so we can just use them without declaring them. <br>
<ul><li><code>stdin</code> Standard Input - Keyboard</li>
<li><code>stdout</code> Standard Out - Screen</li>
<li><code>stderr</code> Standard Error - Screen</li></ul></li>
<li>However, many operating systems allow these default meanings to be changed by <strong>redirection</strong>.</li></ul></li>
<li><p>Text Files versus Binary Files</p>

<ul><li> supports two kinds of files: text and binary.</li>
<li>The bytes in a <strong>text file</strong> represent characters, making it possible for a human to examine the file or edit it. <br>
<ul><li>Text files are divided into lines. Each line in a text file normally ends with with one or two special characters. <br>
<ul><li>In windows, the end-of-line marker is a carriage-return character <code>\x0d</code> followed by a line-feed character <code>\x0a</code>.</li>
<li>In Unix and newer versions of Mac OS, the EOL marker is a single line-feed character.</li></ul></li>
<li>Text files may contain a special end-of-file marker. <br>
<ul><li>Windows - <code>\x1a</code> - Control-Z</li>
<li>Most other operating systems, including UNIX, have no special end-of-file character.</li></ul></li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="222-file-operations">22.2 File Operations</h3>

<ul>
<li>Openning a File <br>
<ul><li><code>File * fopen(const char * restrict filename, const char * restrict mode);</code></li>
<li>Opening a file for use as a stream requires a calJ of the <code>fopen</code> function. <br>
<ul><li>its first argument is a string containing the name of the tile to be opened. </li>
<li>Its second argument is a mode string that specifies what operations we intend to perform on the file.</li>
<li><code>fopen</code> returns a file pointer that the program can (and usually wiJI) save in a variable and use later whenever H needs to perform an operalion on the file. </li>
<li>When it can't open a file, <code>fopen</code> returns a null pointer. </li></ul></li></ul></li>
<li>Modes <br>
<ul><li>For text file <br>
<ul><li>"r" open for reading</li>
<li>"w" open for writing (file need not exist)</li>
<li>"a" open for appending (file need not exist)</li>
<li>"r+" open for reading and writing, starting at beginning</li>
<li>"w+" open for reading and writing (truncate if file exists)</li>
<li>"a+" open for reading and writing (append if file exists)</li></ul></li>
<li>For Binary File <br>
<ul><li>We need to include the letter b in the mode string(after the original letter or letters).</li></ul></li></ul></li>
<li>Closing a File <br>
<ul><li><code>int fclose(FILE * stream)</code></li>
<li>The fclose function allows a program to close a file that ifs no longer using.</li>
<li>The argument to fclose must be a file pointer obtained from a call of <code>fopen</code> or <code>freopen</code>.</li>
<li><code>fclose</code> returns zero if the file wasclosed sucessfully; otherwise, it returns the error code EOF.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span></code></li><li class="L1"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdlib.h&gt;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="com">#define</span><span class="pln"> FILE_NAME </span><span class="str">"example.dat"</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">){</span></code></li><li class="L6"><code class="language-C"><span class="pln">    FILE </span><span class="pun">*</span><span class="pln">fp</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="pln">    fp </span><span class="pun">=</span><span class="pln"> fopen</span><span class="pun">(</span><span class="pln">FILE_NAME</span><span class="pun">,</span><span class="pln"> </span><span class="str">"r"</span><span class="pun">);</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">fp </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L0"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"Can't open %s\n"</span><span class="pun">,</span><span class="pln"> FILE_NAME</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="pun">...</span></code></li><li class="L3"><code class="language-C"><span class="pln">    fclose</span><span class="pun">(</span><span class="pln">fp</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Attaching a File to an Open Stream <br>
<ul><li><code>FILE *freopen(const char * restrict filename, const char * restrict mode, FILE * restrict stream);</code></li>
<li><code>freopen</code> attaches a different file to a stream that's already open.</li>
<li><code>freoepn</code>'s normal return value is its third argument, a file pointer. <br>
<ul><li>if it can't open the new file, <code>freopen</code> will return a null pointer.</li></ul></li></ul></li>
<li>Obtaining File Names from the Command Line <br>
<ul><li>We can supply the program with file names by putting them on the command line.</li>
<li><code>argc</code> is the number of command-line arguments</li>
<li><code>argv</code> is an array of pointers to the argument strings. <br>
<ul><li><code>argv[0]</code> points to the program name</li>
<li><code>argv[1]</code> through <code>argv[argc-1]</code> point to the remaining arguments, and <code>argv[argc]</code> is a null pointer.</li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> argc</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">argv</span><span class="pun">[]){</span></code></li><li class="L1"><code class="language-C"><span class="pun">...</span></code></li><li class="L2"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>File Buffering <br>
<ul><li><strong>Buffering</strong> refers ti data written to a stream is actually stored in a buffer area in memory. <br>
<ul><li>When it is full or the stream is closed, the buffer is flushed - written to the actual output device.</li>
<li>The buffer contains data from the input device; input is read from this buffer instead of the device itself.</li>
<li>Buffering can result in enormous gains in efficiency.</li></ul></li>
<li>The functions in  perform buffering automatically when it seems advantageous.</li>
<li>The buffer is flushed automatically when it's full or the file is closed. <br>
<ul><li>By calling <code>fflush</code>, however, a program can flush a file's buffer as often as it wishes.</li>
<li><code>fflush (fp) ; / * flushes buffer for fp</code></li>
<li><code>fflush (NULL) ; / * flushes all buffers */</code></li>
<li>fflush returns zero if it's successful and EOF if an error occurs. </li></ul></li></ul></li>
<li>Miscellaneous File Operations <br>
<ul><li><code>int remove(const char *filename);</code></li>
<li><code>int rename(const char *old, const char *new);</code></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="223-formatted-io">22.3 Formatted I/O</h3>

<ul>
<li>The <code>...printf</code> Functions <br>
<ul><li>Prototypes <br>
<ul><li><code>int fprintf(FILE * restrict stream, const char * restrict format, ...);</code></li>
<li><code>int fprintf(const char * restrict format, ...);</code></li></ul></li>
<li>Analysis <br>
<ul><li>The fprintf and printf functions write a variable number of data items to an output stream, using a format string to control the appearance of the output. </li>
<li>Both functions return the number of characters wrilten: a negative return value indicates that an error occurred. </li>
<li>The only difference between printf and fprintf is that printf always writes to stdout (the standard output stream). whereas fprintf wrires to the stream indicated by its first argument.</li></ul></li></ul></li>
<li><p><code>...printf</code> Conversion Specifications</p>

<ul><li>Format <br>
<ul><li>"%#012.5Lg"</li>
<li><code>%</code>Specification Indicator</li>
<li><code>#0</code> flag: (optional; more than one permitted) <br>
<ul><li><code>-</code> left-justify wihtin field (the defualt is right justification)</li>
<li><code>+</code> Numbers produced by signed conversions always begin with+ or-. (Normally, only negative numbers are preceded by a sign.) </li>
<li><code>space</code> Nonnegative numbers produced by signed conversions are preceded by a space. (The+ flag overrides the space flag.)</li>
<li><code>#</code> Octal numbers begin with 0. nonzero hexadecimal numbers with Ox or OX. Floating-point numbers always have a decimal poinL Trailing zeros aren't removed from numbers prin1ed with the g or G conversions. </li>
<li><code>0</code> Number are padued with leading 1.eros up to U1e field width</li></ul></li>
<li><code>12</code>Minimum Field Width: (optional)  <br>
</li><li>An item that's too smaJito occupy this number of c haracters will be padded. (By default, spaces are added to the left of tbe item, thus righHustifying it within the field.) </li>
<li>An item that's roo large for the field width will still be d isplayed in its entirety. </li></ul></li>
<li><code>.5</code> Precision: (optional) The meaning of the precision depends on the conversion</li>
<li><code>L</code> Length Modifier: (optional):The presence of a length modifier indicates that the item to be displayed has a type that's longer or shorler than is normal for aparticular conversion specification. </li>
<li><code>g</code>: some special format effects.</li></ul></li></ul></li>
<li><p>The <code>...scanf</code> Functions</p></li>
<li><code>...scanf</code> Format Strings</li>
<li><code>...scanf</code> Conversion Specifications</li>
</ul></div>
</body>
</html>