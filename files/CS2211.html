<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CS2211</title>
</head>
<body>
<div id="wmd-preview" class="wmd-preview"><div class="md-section-divider"></div><div class="md-section-divider"></div><h1 data-anchor-id="txl1" id="cs2211">CS2211</h1><div class="md-section-divider"></div><h2 data-anchor-id="cc6a" id="cs"><code>CS</code></h2><p data-anchor-id="qg3i"><div class="toc"><div class="toc">
<ul>
<li><a href="#cs2211">CS2211</a><ul>
<li><a href="#cs">CS</a></li>
<li><a href="#1-introducing-c">1. Introducing C</a><ul>
<li><a href="#11-history-of-c">1.1 History of C</a></li>
<li><a href="#12-c-based-languages">1.2 C-Based Languages</a></li>
<li><a href="#13-strengths-and-weaknesses-of-c">1.3 Strengths and Weaknesses of C</a></li>
</ul>
</li>
<li><a href="#2-c-fundamentals">2. C Fundamentals</a><ul>
<li><a href="#21-compiling-and-linking">2.1 Compiling and Linking</a></li>
<li><a href="#22-general-form-of-a-simple-program">2.2 General Form of a Simple Program</a></li>
<li><a href="#23-comments">2.3 Comments</a></li>
<li><a href="#24-variables-and-assignment">2.4 Variables and Assignment</a></li>
<li><a href="#25-defining-names-for-constants">2.5 Defining Names for Constants</a></li>
<li><a href="#26-layout-of-a-c-program">2.6 Layout of a C Program</a></li>
</ul>
</li>
<li><a href="#3-formatted-inputoutput">3. Formatted Input/Output</a></li>
<li><a href="#4-expressions">4. Expressions</a><ul>
<li><a href="#41-introduction">4.1 Introduction</a></li>
</ul>
</li>
<li><a href="#42-operators">4.2 Operators</a></li>
<li><a href="#5-selection-statements">5. Selection Statements</a></li>
<li><a href="#6-loops">6. Loops</a></li>
<li><a href="#7-basic-types">7. Basic Types</a></li>
<li><a href="#8-arrays">8. Arrays</a><ul>
<li><a href="#81-definitions">8.1 Definitions</a></li>
<li><a href="#82-one-dimensional-arrays">8.2 One-Dimensional Arrays</a></li>
<li><a href="#83-multidimensional-arrays">8.3 Multidimensional Arrays</a></li>
<li><a href="#84-variable-length-arrays">8.4 Variable-Length Arrays</a></li>
</ul>
</li>
<li><a href="#9-functions">9. Functions</a><ul>
<li><a href="#91-format">9.1 format</a></li>
<li><a href="#92-arguments">9.2 Arguments</a></li>
<li><a href="#93-the-return-statement">9.3 The return Statement</a></li>
</ul>
</li>
<li><a href="#10-program-organization">10. Program Organization</a><ul>
<li><a href="#101-local-variables">10.1 Local Variables</a></li>
<li><a href="#102-external-variables">10.2 External Variables</a></li>
<li><a href="#103-blocks">10.3 Blocks</a></li>
<li><a href="#104-scope">10.4 Scope</a></li>
<li><a href="#105-organizing-a-c-program">10.5 Organizing a C Program</a></li>
</ul>
</li>
<li><a href="#11-pointers">11. Pointers</a><ul>
<li><a href="#111-pointer-variables">11.1 Pointer Variables</a></li>
<li><a href="#112-the-address-and-indirection-operators">11.2 The Address and Indirection Operators</a></li>
<li><a href="#113-pointer-assignment">11.3 Pointer Assignment</a></li>
<li><a href="#114-pointer-as-arguments">11.4 Pointer as Arguments</a></li>
<li><a href="#115-pointers-as-return-values">11.5 Pointers as Return Values</a></li>
</ul>
</li>
<li><a href="#12-pointers-and-arrays">12. Pointers and Arrays</a></li>
<li><a href="#13-strings">13. Strings</a></li>
<li><a href="#14-the-preprocessor">14. The Preprocessor</a><ul>
<li><a href="#141-how-the-preprocessor-works">14.1 How the Preprocessor Works</a></li>
<li><a href="#142-preprocessing-directives">14.2 Preprocessing Directives</a></li>
<li><a href="#143-macro-definitions">14.3 Macro Definitions</a></li>
<li><a href="#144-conditional-compilation">14.4 Conditional Compilation</a></li>
<li><a href="#145-miscellaneous-directives">14.5 Miscellaneous Directives</a></li>
</ul>
</li>
<li><a href="#15-writing-large-programs">15. Writing Large Programs</a><ul>
<li><a href="#151-source-files">15.1 Source Files</a></li>
<li><a href="#152-header-files">15.2 Header Files</a></li>
<li><a href="#153-divding-a-program-into-files">15.3 Divding a Program into Files</a></li>
<li><a href="#154-building-a-multiple-file-program">15.4 Building a Multiple-File Program</a></li>
</ul>
</li>
<li><a href="#16-structures-unions-and-enumerations">16. Structures, Unions, and Enumerations</a><ul>
<li><a href="#161-structure-variables">16.1 Structure Variables</a></li>
<li><a href="#162-structure-types">16.2 Structure Types</a></li>
<li><a href="#163-nested-arrays-and-structures">16.3 Nested Arrays and Structures</a></li>
<li><a href="#164-unions">16.4 Unions</a></li>
<li><a href="#165-enumerations">16.5 Enumerations</a></li>
</ul>
</li>
<li><a href="#17-advanced-uses-of-pointers">17. Advanced Uses of Pointers</a><ul>
<li><a href="#171-dynamic-storage-allocation">17.1 Dynamic Storage Allocation</a></li>
<li><a href="#172-dynamically-allocated-strings">17.2 Dynamically Allocated Strings</a></li>
<li><a href="#173-dynamically-alloated-arrays">17.3 Dynamically Alloated Arrays</a></li>
<li><a href="#174-deallocating-storage">17.4 Deallocating Storage</a></li>
<li><a href="#175-linked-lists">17.5 Linked Lists</a></li>
<li><a href="#176-pointers-to-pointers">17.6 Pointers to Pointers</a></li>
<li><a href="#177-pointers-to-functions">17.7 Pointers to Functions</a></li>
<li><a href="#178-restricted-pointers">17.8 Restricted Pointers</a></li>
<li><a href="#179-flexible-array-members">17.9 Flexible Array Members</a></li>
</ul>
</li>
<li><a href="#18-declarations">18. Declarations</a></li>
<li><a href="#19-program-design">19. Program Design</a></li>
<li><a href="#20-low-level-programming">20. Low-Level Programming</a></li>
<li><a href="#21-the-standard-library">21. The Standard Library</a></li>
<li><a href="#22-inputoutput">22. Input/Output</a></li>
<li><a href="#23-library-support-for-numbers-and-character-data">23. Library Support for Numbers and Character Data</a></li>
<li><a href="#24-error-handling">24. Error Handling</a></li>
<li><a href="#25-international-features">25. International Features</a></li>
<li><a href="#26-miscellaneous-library-functions">26. Miscellaneous Library Functions</a></li>
<li><a href="#27-additional-c99-support-for-mathematics">27. Additional C99 Support for Mathematics</a></li>
</ul>
</li>
</ul>
</div>
</div>
</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="bjbl" id="1-introducing-c">1. Introducing C</h2><div class="md-section-divider"></div><h3 data-anchor-id="1gj9" id="11-history-of-c">1.1 History of C</h3><ul data-anchor-id="6leh">
<li>Origins <br>
<ul><li>1969 By-product of UNIX</li>
<li>1973 Assembly &gt; B &gt; New B &gt; C</li></ul></li>
<li>Standardization <br>
<ul><li>1978 The C Programming Language by Brian Kernighan and Dennis Richie</li>
<li>K&amp;R's fussiness</li>
<li>1980s C's Compiler available on other plarforms</li>
<li>1990 International Organization for Standardization (ISO) (C90)</li>
<li>1999 New ISO publication (C99)</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8qir" id="12-c-based-languages">1.2 C-Based Languages</h3><ul data-anchor-id="oaxs">
<li>C++ includes all the features of C, but adds classes and other features to support OOP</li>
<li>Java is based on C++</li>
<li>C# is a more recent language derived from C++ and Java</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="dfiv" id="13-strengths-and-weaknesses-of-c">1.3 Strengths and Weaknesses of C</h3><pre data-anchor-id="9fdn"><code>* Features
    * C is a low-level language
    * C is a small language - less features but more libraries
    * C is a permissive language
* Strengths
    * Efficiency
    * Portability
    * Power
    * Flexibility
    * Standard Library
    * Integration with UNIX
* Weaknesses
    * C programs can be error-prone
    * C program can be diffilcult to understand
    * Difficult to modify
</code></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="y5kc" id="2-c-fundamentals">2. C Fundamentals</h2><div class="md-section-divider"></div><h3 data-anchor-id="uj9f" id="21-compiling-and-linking">2.1 Compiling and Linking</h3><ul data-anchor-id="z04p">
<li>Preprocessing <br>
<ul><li>Preprocessor checks commands that begin with # - directives</li></ul></li>
<li>Compiling <br>
<ul><li>A compiler translates the source code into object code (machine instructions)</li></ul></li>
<li>Linking <br>
<ul><li>A linker combines the object code produced by the compiler with any additional code needed</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="u9np" id="22-general-form-of-a-simple-program">2.2 General Form of a Simple Program</h3><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="3t6w" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="typ">Directives</span></code></li><li class="L1"><code class="language-C"><span class="com">#include</span><span class="str">&lt;stdio.h&gt;</span></code></li><li class="L2"><code class="language-C"><span class="com">//to indicate that information in &lt;stdio.h&gt; is to be included.</span></code></li><li class="L3"><code class="language-C"><span class="typ">Functions</span></code></li><li class="L4"><code class="language-C"><span class="typ">Library</span><span class="pln"> </span><span class="typ">Functions</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> </span><span class="typ">User</span><span class="pln"> </span><span class="typ">Functions</span></code></li></ol></pre><ul data-anchor-id="1bt4">
<li>Notes:  <br>
<ul><li>main function is mandatory <br>
<ul><li>main should return 0</li>
<li>terminate</li>
<li>signal state</li></ul></li>
<li>Statements <br>
<ul><li>A statement is a command to be executed when the program runs.</li>
<li>Function call and return statement</li></ul></li>
<li>String Literal <br>
<ul><li>a series of characters enclosed in double quotation marks</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="todf" id="23-comments">2.3 Comments</h3><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="0uou" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">/* comments */</span></code></li><li class="L1"><code class="language-C"><span class="com">// comments</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="xt1y" id="24-variables-and-assignment">2.4 Variables and Assignment</h3><ul data-anchor-id="8yos">
<li>Definition <br>
<ul><li>data storage locations are called variables</li></ul></li>
<li>Types <br>
<ul><li>Type specifies what kind of data to hold</li></ul></li>
<li>Declarations <br>
<ul><li>Variables must be declared before use</li>
<li>type + variable name</li>
<li>C99 does not require all declarations to be before statements, but it's a convention</li></ul></li>
<li>Assignment <br>
<ul><li>A variable can be given a value by means of assignment.</li>
<li>Initialization <br>
<ul><li>uninitialized: values that have been declared but not assigned a value yet</li>
<li>intializer: int height = 8;</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="kvuj" id="25-defining-names-for-constants">2.5 Defining Names for Constants</h3><ul data-anchor-id="kvgk">
<li>Macro Definition</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="q1kc" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#defineINCH_PER_POUND 166</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> VALUE </span><span class="pun">(</span><span class="lit">1.0f</span><span class="pun">/</span><span class="lit">3.14159f</span><span class="pun">)</span></code></li><li class="L2"><code class="language-C"><span class="com">//a preprocessing directive</span></code></li></ol></pre><ul data-anchor-id="myfh">
<li>Identifiers and Keywords <br>
<ul><li>Identifiers Definition <br>
<ul><li>Names of variables, functions, macros, and other entiries are called identifiers.</li></ul></li>
<li>Rule <br>
<ul><li>can contain letters, digits, and underscores, but must begin with a letter or underscore</li>
<li>Case sensitive</li></ul></li>
<li>Keywords <br>
<ul><li>Keywords have special significance to C compilers and therefore cannot be used as identifiers.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="evn7" id="26-layout-of-a-c-program">2.6 Layout of a C Program</h3><ul data-anchor-id="cdtc">
<li>Tokens <br>
<ul><li>groups of characters that can't be split up without changing their meaning.</li></ul></li>
<li>Space <br>
<ul><li>has no influence</li>
<li>Statements can be divided over any number of Lines. </li>
<li>Space between Jokens makes it easier for the eye to separate them. </li>
<li>Indentation can make nesting easier to spot.</li>
<li>Blank lines can divide a program into logical units.</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="7pq7" id="3-formatted-inputoutput">3. Formatted Input/Output</h2><ul data-anchor-id="cwp0">
<li>The printf Function <br>
<ul><li>Function <br>
<ul><li>printf(string, expr1, expr2, ...);</li></ul></li>
<li>Conversion Specifications <br>
<ul><li>Functionality <br>
<ul><li>a placeholder representing a value to be fi lled in during printing</li>
<li>The information that follows the %- character specifies bow the value is converted :ti-om its internal form (binary) to printed form (cbaracters)</li></ul></li>
<li>Format <br>
<ul><li>%-m.pX (where m and p are integer constants and X is a letter)</li>
<li>Both m and pare optional; if p is orn.itted, the period that separates m and p is also dropped.</li>
<li>The minimum field width, m, specifies lhe minimum number of characters to print.</li>
<li>The meaning of the precision depends on the choice of X, the conversion specifier</li></ul></li>
<li>Common Conversion Specifier <br>
<ul><li>d- Displays an integer in decimal (base I0) form.</li>
<li>e - Displays a floating-point number in exponential format (scientific notation).</li>
<li>f - Displays a floating-point number in "fixed decimal" format, without an exponent. </li>
<li>g - Displays a tloating-point number in either exponential format or fixed decimal format. depending on the number's site. </li>
<li>Escape Sequences</li>
<li>Alert (bell) \a</li>
<li>Backspace \b</li>
<li>New line \n</li>
<li>Horizontal tab \ t </li></ul></li></ul></li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="5mpj" id="4-expressions">4. Expressions</h2><div class="md-section-divider"></div><h3 data-anchor-id="yixu" id="41-introduction">4.1 Introduction</h3><ul data-anchor-id="44od">
<li>C emphasizes expressions rather than statements</li>
<li>Expressions are built from variables, constants, and operators.</li>
</ul><div class="md-section-divider"></div><h2 data-anchor-id="wr9t" id="42-operators">4.2 Operators</h2><ul data-anchor-id="hqin">
<li>Arithmetic Operators</li>
<li>Unary Arithmetic Operators <br>
<ul><li>+/- to show the sign of a number</li></ul></li>
<li>Binary Arithmetic Operators <br>
<ul><li><ul><li>addition</li></ul></li>
<li><ul><li>subtraction</li></ul></li>
<li><ul><li>multiplication</li></ul></li>
<li>/ division</li>
<li>% remainder</li></ul></li>
<li>Implementation-Defined Behaviour <br>
<ul><li>The behavior when / and % are used with negative operands is implementation-defined in C89.</li>
<li>In C99, the result of a division is always truncated toward zero and the value of i % j has the same sign as i.</li></ul></li>
<li>Operator Precedence <br>
<ul><li>Highest + -</li>
<li>Middle * / %</li>
<li>Lowest + -</li></ul></li>
<li>Operator Associativity <br>
<ul><li>An operator is said to be left associative if it groups from left to right.</li>
<li>The binary arithmetic operators (*, /, %, +, and -) are all left associative</li>
<li>An operator is right associative if it groups from right to left.</li>
<li>The unary arithmetic operators (+ and -) are both right associative</li></ul></li>
<li>Relational Operators</li>
<li>Logical Operators</li>
<li>Assignment Operators <br>
<ul><li>Simple assignment <br>
<ul><li>used for storing a value into a variable</li>
<li>The effect of the assignment v = e is to evaluate the expression e and copy its value into v.</li>
<li>If v and e don’t have the same type, then the value of e is converted to the type of v as the assignment takes place.</li>
<li>in C, however, assignment is an operator, just like +. <br>
<ul><li>The value of an assignment v = e is the value of v after the assignment.</li></ul></li></ul></li>
<li>Side Effect <br>
<ul><li>An operators that modifies one of its operands is said to have side effect.                * Since assignment is an operator, several assignments can be chained together: <br>
<ul><li>i = j = k = 0;</li></ul></li>
<li>The = operator is right associative, so this assignment is equivalent to i = (j = (k = 0));</li>
<li>Lvalues <br>
<ul><li>The assignment operator requires an lvalue as its left operand.</li>
<li>An lvalue represents an object stored in computer memory, not a constant or the result of a computation.</li></ul></li>
<li>Compound Assignment <br>
<ul><li>used for updating a value already stored in a variable</li>
<li>There are nine other compound assignment operators, including the following: -= *= /= %=</li></ul></li></ul></li></ul></li>
<li>Increment and Decrement Operators <br>
<ul><li>C provides special ++ (increment) and -- (decrement) operators.</li>
<li>The ++ operator adds 1 to its operand. The -- operator subtracts 1.</li>
<li>They can be used as prefix operators (++i and –-i) or postfix operators (i++ and i--).</li>
<li>++i means “increment i immediately,” while i+ + means “use the old value of i for now, but increment i later.”</li></ul></li>
<li>Undefined Behaviour <br>
<ul><li>Statements such as c = (b = a + 2) - (a = 1); and j = i * i++; cause undefined behavior.</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="arlo" id="5-selection-statements">5. Selection Statements</h2><p data-anchor-id="6ssx">This Content is omitted.</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="bwln" id="6-loops">6. Loops</h2><p data-anchor-id="yd14">This Content is omitted.</p><hr><div class="md-section-divider"></div><h2 data-anchor-id="luva" id="7-basic-types">7. Basic Types</h2><hr><div class="md-section-divider"></div><h2 data-anchor-id="9via" id="8-arrays">8. Arrays</h2><div class="md-section-divider"></div><h3 data-anchor-id="i91s" id="81-definitions">8.1 Definitions</h3><ul data-anchor-id="r62g">
<li>An array is a data structure containing a number of data values, all of which have the same type.</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8qsd" id="82-one-dimensional-arrays">8.2 One-Dimensional Arrays</h3><ul data-anchor-id="7zu6">
<li>Array Subscripting <br>
<ul><li>To access a particular element of an array. we write the atTay name followed by an integer value in square brackets (this is referred to as subscripting or indexing the array).</li></ul></li>
<li>Initialization <br>
<ul><li>Array Initializer <br>
<ul><li>The common form of array initializer is a list of constant expressions enclosed in braces and separaLed by commas</li>
<li>If the initializer is smaller than the array. the remaining elements of the array are given the value 0</li>
<li>If an initializer is present, the length of the array may be omitted</li></ul></li>
<li>Designated Initializers <br>
<ul><li>int a[l5] = {[2] = 29, [9] = 7, [14] = 48};</li>
<li>Each number in b rackets is said to be a designator. </li>
<li>Designators must be integer constant expressions.</li></ul></li>
<li>Using the sizeof Operator with Arrays <br>
<ul><li>The sizeof operator can detemine the size of an array (in bytes).</li>
<li>(sizeof (a) / sizeof (a [0])</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="mfnc" id="83-multidimensional-arrays">8.3 Multidimensional Arrays</h3><ul data-anchor-id="7qdg">
<li>Functionality <br>
<ul><li>An array may have any number of dimensions. </li>
<li>C stores arrays in row-major order, wilh row 0 first, then row l. and so forth. </li></ul></li>
<li>Initializing a Multidimensional Array <br>
<ul><li>We can create an initializer for a tw
</li><li>If an initializer is large enough to fiU a multidimensional array. the remaining elements are given the value 0.</li>
<li>If an inner list is not  enough to fill a row, rhe remaining elements in the row are initialized to 0.</li>
<li>We can even omit the inner braces.</li>
<li>In C99, designated initializers work with multidimensional arrays</li></ul></li>
<li>Constant Arrays</li>
<li>An array thafs been declared canst should not be modified by the program</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="jgdp" id="84-variable-length-arrays">8.4 Variable-Length Arrays</h3><pre data-anchor-id="387u"><code>* only supported in C99
</code></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="omfl" id="9-functions">9. Functions</h2><div class="md-section-divider"></div><h3 data-anchor-id="dgpl" id="91-format">9.1 format</h3><ul data-anchor-id="krz1">
<li>Write a Function <br>
<ul><li>[return type] [function name] (parameters) { body }</li></ul></li>
<li>Call a function <br>
<ul><li>function name (arguments);</li></ul></li>
<li>Definitions <br>
<ul><li>Functions may not return arrays. but there are no other restrictions on the return type. </li>
<li>Specifying that the return Lype is void indicates that the function doesn't return a value. </li>
<li>lf the return type is omitted in C89, the function is presumed to retum a value of type int. In C99. it's illegal to omit the return type of a function. </li>
<li>Variables declared in the body of a runction belong exclusively to that function: they can't be examined or modified by other functions. </li></ul></li>
<li>Function Declarations</li>
<li>Implicit Declarations <br>
<ul><li>a definition of a function is present prior to any call of the function</li></ul></li>
<li>Function Declaration</li>
<li>a declaration of a function is present prior to any call of the function</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="5xjb" id="92-arguments">9.2 Arguments</h3><ul data-anchor-id="53pi">
<li>Argument Passing <br>
<ul><li>In C, arguments are passed by value except for array.</li></ul></li>
<li>Argument Conversions <br>
<ul><li>The compiler governing how the arguments are converted depends on whether or not the compiler has seen a prototype for the funcrion (or the function· s full definition) prior to the call.</li>
<li>YES - &gt; each argument is implicitly converted</li>
<li>NO -&gt; default argument promotions <br>
<ul><li>1) float to be double</li>
<li>2) char and short to int</li></ul></li></ul></li>
<li>Array Argument <br>
<ul><li>we may have to provide the length as one argument</li></ul></li>
<li>Variable-Length Array Parameters <br>
<ul><li>(int n, int a[n])</li></ul></li>
<li>Compound Literals <br>
<ul><li>total= sum_array((int []){3, 0, 3, 4, 1}, 5); </li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="5f7l" id="93-the-return-statement">9.3 The return Statement</h3><ul data-anchor-id="umu2">
<li>Program Termination <br>
<ul><li>Return in Main</li>
<li>Older C programs often omit main's return type, taking advantage of the fact that it traditionally defaults to int</li>
<li>The value returned by main is a status code that-in some operating systems can be tested when the program terminates.</li></ul></li>
<li>The exit Function <br>
<ul><li>exit(0);</li>
<li>exit(EXIT_SUCCESS);</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="y0l8" id="10-program-organization">10. Program Organization</h2><div class="md-section-divider"></div><h3 data-anchor-id="9c9b" id="101-local-variables">10.1 Local Variables</h3><ul data-anchor-id="bc8k">
<li>Introduction <br>
<ul><li>Definition <br>
<ul><li>A variable declared in the body of a function is said to be local to the function.</li></ul></li>
<li>Property <br>
<ul><li>Automatic storage duration</li>
<li>Block scope</li></ul></li>
<li>Static Local Variables <br>
<ul><li>Puting static in the declaration of a local variable causes it to have static storage duration.</li>
<li>Static variable has a permanent storage location, so it retains its value throughout the program.</li>
<li>A static local variable still has block scope, so it's not visible to other functions.</li></ul></li>
<li>Parameters <br>
<ul><li>parameters have the same properties as local variables.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="9dqa" id="102-external-variables">10.2 External Variables</h3><ul data-anchor-id="aab7">
<li>Definition <br>
<ul><li>Functions can also communicate through external variables - variables that are declared outside the body of any function.</li></ul></li>
<li>Propertiies <br>
<ul><li>Static storafe duration</li>
<li>File scope</li></ul></li>
<li>Pros and Cons of External Variables <br>
<ul><li>Cons <br>
<ul><li>If we change an external variable during maintenance, we'll need to check every function.</li>
<li>If an external variable is assigned an incorrect value, it may be difficult to identify the guilty function</li>
<li>Functions that rely on external variables are hard to reuse.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="gsc7" id="103-blocks">10.3 Blocks</h3><ul data-anchor-id="9fos">
<li>The storage duration of a varaibled declared in a block is automatic: storage for the variable is allocated when the block is entered and deallocated when the block is exited.</li>
<li>The variable has block scope.</li>
<li>A variable that belongs to a block can be declared static to give it static storage duration.</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="roiy" id="104-scope">10.4 Scope</h3><ul data-anchor-id="iuta">
<li>When a declaration inside a block names an identifier that's already visible (because it has file scope or because it is declared in an enclosing block), the new declaration temporarily hides the old one, and the identifier takes on a new meaning.</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="c4zi" id="105-organizing-a-c-program">10.5 Organizing a C Program</h3><ul data-anchor-id="7zan">
<li>Format</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="rbof" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#include</span><span class="pln"> directives</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> directives</span></code></li><li class="L2"><code class="language-C"><span class="typ">Type</span><span class="pln"> definitions</span></code></li><li class="L3"><code class="language-C"><span class="typ">Declarations</span><span class="pln"> of external variables</span></code></li><li class="L4"><code class="language-C"><span class="typ">Prototypes</span><span class="pln"> </span><span class="kwd">for</span><span class="pln"> functions other than main</span></code></li><li class="L5"><code class="language-C"><span class="typ">Defnition</span><span class="pln"> of main</span></code></li><li class="L6"><code class="language-C"><span class="typ">Definitions</span><span class="pln"> of other functions</span></code></li></ol></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="v28q" id="11-pointers">11. Pointers</h2><div class="md-section-divider"></div><h3 data-anchor-id="p0u3" id="111-pointer-variables">11.1 Pointer Variables</h3><ul data-anchor-id="hc3s">
<li>Declaring Pointer Variable <br>
<ul><li>the name of a pointer variable must be preceded by an asterisk.</li>
<li><code>int *p;</code> </li>
<li>This declaration states that p is a pointer variable capable of pointing to objects of type int. </li>
<li>Pointer variables can appear in declarations along with other variables;</li>
<li>C requires that every pointer variable point only to objectc; of a particular type (the referenced type)</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8fyq" id="112-the-address-and-indirection-operators">11.2 The Address and Indirection Operators</h3><ul data-anchor-id="safu">
<li>The Address Operator &amp; <br>
<ul><li><code>p = &amp;i;</code> </li></ul></li>
<li>The Indirection Operator * <br>
<ul><li>Once a pointer variable points to an object. we can use the * (indirection) operator to access whar's stored in the object.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="339v" id="113-pointer-assignment">11.3 Pointer Assignment</h3><ul data-anchor-id="duuc">
<li>C allows the use of assignment operator to copy pointer, provided that they have the same type.</li>
<li>Any number of pointer variables may point to the same object. </li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="9hoo" id="114-pointer-as-arguments">11.4 Pointer as Arguments</h3><ul data-anchor-id="bcpn">
<li>Modify Arrays</li>
<li>Return Two Results</li>
<li>Scan Function</li>
<li>Using const to Protect Argument <br>
<ul><li>We can use the word const to document that a function won't change an object whose address is passed to the function. cons t goes in the parameter's E!l11 declaration, just before the specification of its type</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="03wd" id="115-pointers-as-return-values">11.5 Pointers as Return Values</h3><ul data-anchor-id="97lj">
<li>Then the variable has to be decaled as static</li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="r3a6" id="12-pointers-and-arrays">12. Pointers and Arrays</h2><hr><div class="md-section-divider"></div><h2 data-anchor-id="twlk" id="13-strings">13. Strings</h2><hr><div class="md-section-divider"></div><h2 data-anchor-id="0b4t" id="14-the-preprocessor">14. The Preprocessor</h2><div class="md-section-divider"></div><h3 data-anchor-id="efzo" id="141-how-the-preprocessor-works">14.1 How the Preprocessor Works</h3><ul data-anchor-id="6zl4">
<li>The behavior of the preprocessor is controlled by <strong>preprocessing directives</strong>: commands that begin with a # character.  <br>
<ul><li>The <strong>#define directive</strong> defines a <strong>macro</strong> - a name that represents something else, such as a constant or frequently used expression. </li>
<li>The <strong>#include</strong> directive tells the preprocessor to open a pruticular file and "include" its contents as part of the file being compiled. </li></ul></li>
<li>The Process of Preprocessing <br>
<ul><li>The input to the preprocessor is a C program, possibly containing directives. </li>
<li>The preprocessor executes these directives, removing them in the process. </li>
<li>The output of the preprocessor is another C program: an edited version of the origjnal program, containing no directives. </li>
<li>The preprocessor's output goes directly into the compiler. which checks the program for errors and translates it to object code.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="2txc" id="142-preprocessing-directives">14.2 Preprocessing Directives</h3><ul data-anchor-id="rvol">
<li>Most preprocessing directives fall into one of three categories:  <br>
<ul><li><strong>Macro definition</strong>: The #define directive defines a macro; the #undef directive removes a macro definition. </li>
<li><strong>File inclusion</strong>: The #include directive causes Lhe contents of a specified file to be included in a program. </li>
<li><strong>Conditional compilation</strong>: the #if, #ifdef, #ifndef, #eli£, #else, and #endif directives allow blocks of text to be either included in or excluded from a program, depending on conditions that can be tested by the preprocessor. </li></ul></li>
<li>There are a few rules that apply to all directives <br>
<ul><li>Directives always begin with the <strong># symbol</strong>.</li>
<li>Any number of spaces and horizontal tab characters may <strong>separate the tokens</strong> in a directive. </li>
<li>Directives always <strong>end at the first new-line character</strong>, unless explicitly continued.</li>
<li>Directives can appear <strong>anywhere</strong> in a program. </li>
<li><strong>Comments</strong> may appear on the same line as a directive. </li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="8i8p" id="143-macro-definitions">14.3 Macro Definitions</h3><ul data-anchor-id="vp5l">
<li>Simple Macros <br>
<ul><li>The definition of a <strong>simple macro</strong> (or <strong>object-like macro</strong>, as it·s called in the C standard) has the form, <code>#define identifier replacement-list</code>, where replacement-list is any sequence of <strong>preprocessing tokens</strong>.</li>
<li>When it encounters a macro definition, the preprocessor makes a note that identifier represents replacement-list; wherever identifier appears later in the file, the preprocessor substitutes replacement-list. </li>
<li>lncidentnlly. it's legal for a macro's replacement list to be empty.</li></ul></li>
<li>Use #define to create names for constants has several significant advantages <br>
<ul><li>It makes programs easier to read.</li>
<li>It makes programs easier to modify</li>
<li>It helps avoid inconsistencies and typographical errors.</li>
<li>Making minor changes to the syntax of C <br>
<ul><li>like: <code>#define BEGIN {</code> or <code>#define END }</code></li></ul></li>
<li>Renaming types. <br>
<ul><li><code>#define BOOL int</code></li></ul></li>
<li>Controlling conditional compilation</li></ul></li>
<li><p>Parameterized Macros</p>

<ul><li>The definition of a <strong>parameterized macro</strong> (also known as a function-like macro) has the form <code>#define identifier( x1, x2, x3, x4, ..., xn) replacement-list</code> <br>
<ul><li>There must be no space between the macro name and the left parenthesis. lf space is left. the preprocessor will assume tbat we're defining a simple macro; it will treat (x 1 , x2 ,..., xn,) as part of the replacement list. </li></ul></li>
<li>Using a parameterized macro instead of a true function has a couple of advantages <br>
<ul><li>The program may be slightly faster. (however, the C99's inline functions provide a way to avoid this overhead without the use of macros)</li>
<li>Macros are generic </li></ul></li>
<li>But parameterized macros also have disadvantages <br>
<ul><li>The compiled code will often be larger.</li>
<li>Arguments aren't type-checked.</li>
<li>It's not possible to have a pointer to a macro.</li>
<li>A macro may evaluate its arguments more than once. <br>
<ul><li>like <code>n = MAX(i++, j);</code></li></ul></li></ul></li></ul></li>
<li><p>The # Operator</p>

<ul><li><strong>The # operator</strong> convet s a macro argument into a string iteral</li>
<li>it can appear only in rhe replacement list of a parameterized macro. </li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="cuwo" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#define</span><span class="pln"> PRINT_INT</span><span class="pun">(</span><span class="pln">n</span><span class="pun">)</span><span class="pln"> printf</span><span class="pun">(#</span><span class="pln">n </span><span class="lit">11</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="pln">d\n</span><span class="str">", n) </span></code></li><li class="L1"><code class="language-C"><span class="str">PRINT_INT(i/j); </span></code></li><li class="L2"><code class="language-C"><span class="str">//which is equivalent to</span></code></li><li class="L3"><code class="language-C"><span class="str">printf("</span><span class="pln">i</span><span class="pun">/</span><span class="pln">j</span><span class="str">" "</span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="pln">d\n</span><span class="str">", i/j); </span></code></li><li class="L4"><code class="language-C"><span class="str">/*which is equivalent to</span></code></li><li class="L5"><code class="language-C"><span class="str">printf("</span><span class="pln">i</span><span class="pun">/</span><span class="pln">j </span><span class="pun">=</span><span class="pln"> </span><span class="pun">%</span><span class="pln">d\n</span><span class="str">", i/j); </span></code></li></ol></pre><ul data-anchor-id="ou5b">
<li><p>The ## Operator </p>

<ul><li>The ## opcrawr can "paste" two mkens (idemHiers. for example) together to form a single token. </li></ul></li>
<li><p>General Properties of Macros</p></li>
<li>Creating Longer Macros</li>
<li>Predefined Macros</li>
<li>Additional Predefined Macros in C99</li>
<li>Empty Macro Arguments</li>
<li>Macros with a Variable Number of Arguments</li>
<li>The __func__ identifier </li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="fb77" id="144-conditional-compilation">14.4 Conditional Compilation</h3><ul data-anchor-id="u47l">
<li>The #if and #endif Directives</li>
<li>The defined Operator</li>
<li>The #ifdef and #ifndef Directives</li>
<li>The #elif and #else Directives</li>
<li>Uses of Conditional Compilation</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="6002" id="145-miscellaneous-directives">14.5 Miscellaneous Directives</h3><ul data-anchor-id="b68u">
<li>The #error Directive</li>
<li>The #line Directive</li>
<li>The #progma Directive</li>
<li>The _Progma Operator</li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="w2c8" id="15-writing-large-programs">15. Writing Large Programs</h2><div class="md-section-divider"></div><h3 data-anchor-id="yxg5" id="151-source-files">15.1 Source Files</h3><ul data-anchor-id="irym">
<li>By convention, source files have the extension <strong>.c</strong>.</li>
<li>Each source file3 contains part of the program, primarily definitions of functions and variables <br>
<ul><li>One source file must contain a function named <strong>main</strong>, which serves as the starting point for the program.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="m1jn" id="152-header-files">15.2 Header Files</h3><ul data-anchor-id="c8h9">
<li>The #include Directive <br>
<ul><li>Usage <br>
<ul><li>The <code>#include</code> directive tells the preprocessor to open a specified file and insert its contents into the current file.</li>
<li>Thus, if we want several source files to have access to the same information, we'll put that information in a file and then use <code>#include</code> to bring the file's contents into each of the source files.</li>
<li>Files that are included in this fashion are called <strong>header files</strong>, and have the extension <code>.h</code>.</li></ul></li>
<li>Three forms <br>
<ul><li>The first form is used for header files that belong to C's own library <br>
<ul><li><code>#include &lt;filename&gt;</code></li>
<li>Search the directory in which system header files reside.</li></ul></li>
<li>The second form is used for all other header files, including any that we write: <br>
<ul><li><code>#include "filename"</code> </li>
<li>Search the current directory, then search the directory in which system header files reside.</li></ul></li>
<li>The third form involves the use of defined tokens, and is used less often. <br>
<ul><li><code>#include tokens</code></li>
<li>Tokens refer to any sequence of preprocessing tokens. The preprocessor will scan the tokens and replace any macros that it finds.</li>
<li>After macro replacement, the resultign directive must match one of the other forms of #include.</li>
<li>The advantage of the third one is that the file ame can be defined by a macro rather than being "hard-coded" into the directive itself.</li></ul></li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="xvsg" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#if defined(IA32)</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="com">#define</span><span class="pln"> CPU_FILE </span><span class="str">"ia32.h"</span></code></li><li class="L2"><code class="language-C"><span class="com">#elif</span><span class="pln"> </span><span class="kwd">defined</span><span class="pun">(</span><span class="pln">IA64</span><span class="pun">)</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="com">#define</span><span class="pln"> CPU_FILE </span><span class="str">"ia64.h"</span></code></li><li class="L4"><code class="language-C"><span class="com">#elif</span><span class="pln"> </span><span class="kwd">defined</span><span class="pun">(</span><span class="pln">AMD64</span><span class="pun">)</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="com">#define</span><span class="pln"> CPU_FILE </span><span class="str">"amd64.h"</span></code></li><li class="L6"><code class="language-C"><span class="com">#endif</span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="com">#include</span><span class="pln"> CPU_FILE</span></code></li></ol></pre><ul data-anchor-id="8dmc">
<li>Sharing Macro Definitions and Type Definitios <br>
<ul><li>The definitons that need to be shared by several source files should go into the header files.</li>
<li>Advantages oPutting Definitions of macros and types in header files  <br>
<ul><li>Save time by not having to copy the definition into the source files where they're needed.</li>
<li>The program becomes easier to modify.</li>
<li>We don't have to worry about inconsistencies caused by source files containing different definitions of the same macro or type.</li></ul></li></ul></li>
<li>Sharing Functions Prototypes <br>
<ul><li>Always include the header file declaring a function in the source file that contain's that function's definition.</li>
<li>Failure to do so can cause hard-to-find bugs, since calls of f elsewhere in the program may not match f's definition.</li></ul></li>
<li>Sharing Variable Declarations <br>
<ul><li>Comparison <br>
<ul><li><code>int i;</code> <br>
<ul><li>This statement declares i to be a variable of type int, but also defines i by setting aside space for i.</li></ul></li>
<li><code>extern int a[];</code> <br>
<ul><li>This statement declares i without defining it.</li>
<li><code>extern</code> informs the compiler that i is defined elsewhere in the program (most likely in a different source file), so there is no need to allocate space for it.</li>
<li>Since the compiler doesn't allocate space for a at this time.</li></ul></li></ul></li>
<li>Usage <br>
<ul><li>To share a variable <code>i</code> among several files, the definition <code>int i;</code> should be first put into one file;</li>
<li>If i needs to be initialized, the initializer would go here too.</li>
<li>The other file should contain only the declaration of i: <code>extern int i;</code></li></ul></li>
<li>Caution <br>
<ul><li>To avoid inconsistency among all declarations, the declarations of shared variables are usually put put in header files.</li></ul></li></ul></li>
<li>Nested Includes <br>
<ul><li>A header file may itself contain <code>#include</code> directives.</li></ul></li>
<li>Protecting Header Files <br>
<ul><li>It's a good idea to protect all header files against multiple inclusion; <br>
<ul><li>To avoid causing a compilation error.</li>
<li>To avoid unnecessary recompilation of the same header file.</li></ul></li>
<li>To protect a header file, we'll enclose the contents of the file in an <code>#ifndef</code> and <code>#endif</code> pair.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="9oqj" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#ifndef</span><span class="pln"> BOOLEAN_H</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> BOOLEAN_H</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="com">#define</span><span class="pln"> TRUE </span><span class="lit">1</span></code></li><li class="L4"><code class="language-C"><span class="com">#define</span><span class="pln"> FALSE </span><span class="lit">0</span></code></li><li class="L5"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> </span><span class="typ">Bool</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="com">#endif</span></code></li></ol></pre><ul data-anchor-id="vxe3">
<li>#error Directives in Header Files <br>
<ul><li><code>#error</code> directives are often put in header files to check for conditions under which the header file shouldn't be included.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="q3f1" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#ifndef</span><span class="pln"> __STDC___</span></code></li><li class="L1"><code class="language-C"><span class="com">#error</span><span class="pln"> </span><span class="typ">This</span><span class="pln"> header requires a </span><span class="typ">Standard</span><span class="pln"> C compiler</span></code></li><li class="L2"><code class="language-C"><span class="com">#endif</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="loqo" id="153-divding-a-program-into-files">15.3 Divding a Program into Files</h3><ul data-anchor-id="lgvw">
<li>Include the definition of all the functions in a class (like foo.c).</li>
<li>include the prototypes of the functiosn defined in foo.c that are expected to be used in other functions in the header file (like foo.h)</li>
<li>include foo.h in foo.c so that the compiler can check that the function prototypes in foo.h are consistent with the definitions in foo.c.</li>
<li>The <code>main</code> function will go in a file whose name matches the name of the program - if we want the program to be known as bar, then the main should be in the file bar.c</li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="lpo8" id="154-building-a-multiple-file-program">15.4 Building a Multiple-File Program</h3><ul data-anchor-id="dsq2">
<li>Process <br>
<ul><li>Compiling <br>
<ul><li>Each source file in the program must be compiled separately.</li>
<li>Header files don't need to be compiled as its contents are automatically compiled whenever a soruce file that includes it is compiled.</li>
<li>The files compiled are knwon as <strong>object files</strong>, and they have the extension .o in UNIX and .obj in Windows.</li></ul></li>
<li>Linking <br>
<ul><li>The linker combines the object files created in the previous step along with code for library functions to produce an executable file.</li></ul></li>
<li>Most compilers allow us to build a program in a single step <br>
<ul><li><code>gcc -o justify justify.c line.c word.c</code></li></ul></li></ul></li>
<li><p>Makefiles</p>

<ul><li>Introduction <br>
<ul><li>To make it easier to build large programs, UNIX originated the concept of the <strong>makefile</strong>, a file containing the information necessary to build a program.</li>
<li>A makefile not only lists the files that are part of the program, but also describes <strong>dependencies</strong> among the files.</li></ul></li>
<li>Definitions <br>
<ul><li>Below are four groups of lines, and each group is known as a <strong>rule</strong>.</li>
<li>The first line in each rule gives a <strong>target</strong> file, followed by the files on which it depends.</li>
<li>The decond line is a <strong>command</strong> to be executed if the target should need to be rebuilt because of a change to one of its dependent files.</li></ul></li>
<li>Cautions <br>
<ul><li>Each command in a makefile must be preceded by a tab character, not a series of spaces.</li>
<li>A makefile is normally stored in a file named Makefile (or makefile), and when the make utility is used, it automatically checks the current directory for a file with one of these names.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="67rz" style=""><ol class="linenums"><li class="L0"><code class="language-makefile"><span class="pln">justify</span><span class="pun">:</span><span class="pln"> justify</span><span class="pun">.</span><span class="pln">o word</span><span class="pun">.</span><span class="pln">c line</span><span class="pun">.</span><span class="pln">o</span></code></li><li class="L1"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">o justify justify</span><span class="pun">.</span><span class="pln">o word</span><span class="pun">.</span><span class="pln">o line</span><span class="pun">.</span><span class="pln">o</span></code></li><li class="L2"><code class="language-makefile"></code></li><li class="L3"><code class="language-makefile"><span class="pln">justify</span><span class="pun">.</span><span class="pln">o</span><span class="pun">:</span><span class="pln"> justify</span><span class="pun">.</span><span class="pln">c word</span><span class="pun">.</span><span class="pln">h line</span><span class="pun">.</span><span class="pln">h</span></code></li><li class="L4"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">c justify</span><span class="pun">.</span><span class="pln">c</span></code></li><li class="L5"><code class="language-makefile"></code></li><li class="L6"><code class="language-makefile"><span class="pln">word</span><span class="pun">.</span><span class="pln">o</span><span class="pun">:</span><span class="pln"> word</span><span class="pun">.</span><span class="pln">c word</span><span class="pun">.</span><span class="pln">h</span></code></li><li class="L7"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">c word</span><span class="pun">.</span><span class="pln">c</span></code></li><li class="L8"><code class="language-makefile"></code></li><li class="L9"><code class="language-makefile"><span class="pln">line</span><span class="pun">.</span><span class="pln">o</span><span class="pun">:</span><span class="pln"> line</span><span class="pun">.</span><span class="pln">c line</span><span class="pun">.</span><span class="pln">h</span></code></li><li class="L0"><code class="language-makefile"><span class="pln">    gcc </span><span class="pun">-</span><span class="pln">c line</span><span class="pun">.</span><span class="pln">c</span></code></li></ol></pre><ul data-anchor-id="2inq">
<li>Errors During Linking <br>
<ul><li>Misspelling</li>
<li>Missing files</li>
<li>Missing Libraries</li></ul></li>
<li>Rebuilding a Program <br>
<ul><li>To save time, the rebuilding process should recompile only those files that might be affected by the latest change.</li></ul></li>
<li>Defining Macros Outside a Program <br>
<ul><li>c compilers usually provide some method of specifying the value of a macro at the time a program is compiled, which is the -D function in gcc</li>
<li>Most compilers also support the -U option, which undefines a macro as if by using #undef.</li></ul></li>
</ul><hr><div class="md-section-divider"></div><h2 data-anchor-id="1sa9" id="16-structures-unions-and-enumerations">16. Structures, Unions, and Enumerations</h2><div class="md-section-divider"></div><h3 data-anchor-id="0ru5" id="161-structure-variables">16.1 Structure Variables</h3><ul data-anchor-id="ymib">
<li>Introduction <br>
<ul><li>A <strong>structure</strong> is a collection of values, possibly of different types.</li>
<li>The elements of a structure, its <strong>member</strong>, aren't reuired to have the same type.</li>
<li>The members of a structure have names - therefore to select a particular member, we specify its name, not its position.</li></ul></li>
<li>Declaring Structure Variables <br>
<ul><li>In the codes below, <code>struct{ ... }</code> specifies a type, while <code>part1</code> and <code>part2</code> are variables of that type.</li>
<li>'The members of a structure are stoed in memory in the order in which they are declared.</li>
<li>Each structure represents a new scope; any names declared in that scope won't conflict with other names in a program - each structure has a separate <strong>name space</strong> for its members.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ik5e" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part1</span><span class="pun">,</span><span class="pln"> part2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="7bcq">
<li>Initializing Structure Variables <br>
<ul><li>A structure variable may be initialized at the time it's declared.</li>
<li>To initialize a structure, we prepare a list of values to be stored in the structure and enclose it in braces.</li>
<li>The values in the initializer must appear in the same order as the members of the structure.</li>
<li>Structure initializers follow rules similar to those for array initializer. <br>
<ul><li>Expressions used in a structure initializer must be constant (but this restriction is relaxed in C99)</li>
<li>An initializer can have fewer members than the structure it's initializing. Any leftover members are given 0 as their initial value.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="0w1w" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">527</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">},</span></code></li><li class="L5"><code class="language-C"><span class="pln"> part2 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">914m</span><span class="pln"> </span><span class="str">"Printer cable"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5</span><span class="pun">};</span></code></li></ol></pre><ul data-anchor-id="lj0s">
<li>Designated Initializers <br>
<ul><li>In a designated initializer, each value labeled by the name of of the member that it nitializes. <br>
<ul><li>The combination of the period and the member name is called a <strong>designator</strong></li></ul></li>
<li>Designated initializers have several advantages. <br>
<ul><li>They are easier to read and check for correctness.</li>
<li>The values in the initializer don't have to be placed in the same order that the members are listed in the structure.</li>
<li>The order of the members can be changed in the future without affecting designated initializers.</li></ul></li>
<li>Not all values listed in a designated initializer need to be prefixed by a designator.</li>
<li>Any members that the initializer fails to account for are set to zero.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="hh4i" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> </span><span class="lit">527</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">on_hand </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">},</span></code></li><li class="L5"><code class="language-C"><span class="pln"> part2 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="pun">.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> </span><span class="lit">527</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">on_hand </span><span class="pun">=};</span></code></li></ol></pre><ul data-anchor-id="myb2">
<li>Operations on Structures <br>
<ul><li>To access a member within a structure, we write the name of the structure first, then a period, then the name of the member.<br><code>part1.number</code></li>
<li>The members of a structure are lvalues, so they can appear on the left side of an assignment or as the operand in an increment or decrement expression.<br><code>part1.number = 258</code><br><code>part1.on_hand++;</code></li>
<li>The . period that we use to access a structure member is actuallt a C operator, and it has the same precedence as the postfix ++ and -- operators, so it takes precedence over nearly all other operators.</li>
<li>The other major structure operation is assignment:<br><code>part2 = part1;</code><br>The effect of this statement is to copy <code>part1.number</code> into <code>part2.number</code>, <code>part1.name</code> into <code>part2.name</code>and so on. <br>
<ul><li>The = operator can be used only with structures of <strong>compatible</strong> types.</li>
<li>Two structures declared at the same time are compatible.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="2vu5" id="162-structure-types">16.2 Structure Types</h3><ul data-anchor-id="89qh">
<li>Introduction <br>
<ul><li>If we want to declare a variable of a structure first, and then declare another one at a later time, without the type of the structure, we would have to write the structure twice.</li>
<li>This leads to two difficuties <br>
<ul><li>One is that the program will soon be bloated to be too large.</li>
<li>The other is that those two variables declared at different time and position will be considered to be not compatible, so they cannot assign value to each other.</li></ul></li></ul></li>
<li>Declaring a Structure Tag <br>
<ul><li>A <strong>structure tag</strong> is a name used to identify a particular kind of structure.</li>
<li>Once we've created the name tag, we can use it to declare variables, but we can't drop the word <code>struct</code>. <br>
<ul><li>Since structures tags aren't recognized unless preceded by the word <code>struct</code>, they don't conflict with other names used in a program.</li>
<li>The declaration of a structure tag can be conbined with the declaration of structure variables;</li>
<li>Declaring a structure tag is mantatorg when structure is to be used in a linked list.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="3sfu" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NALE_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln">part3</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part part1</span><span class="pun">,</span><span class="pln"> part2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="pwfk">
<li>Defining a Structure Type <br>
<ul><li>We can use <code>typedef</code> to define a genuine type name. <br>
<ul><li>The name of the type must come at the end, not after the word struct.</li>
<li>Then we can use the name of the type in the same way as the built-in types, without using together with the <code>struct</code>.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="qn48" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> name</span><span class="pun">[</span><span class="pln">NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln"> </span><span class="typ">Part</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="typ">Part</span><span class="pln"> part1</span><span class="pun">,</span><span class="pln"> part2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="6kxp">
<li>Structures as Arguments and Return Values <br>
<ul><li>Passing a structure to a function and returning a structure from a function both require making a copy of all members in the structure. <br>
<ul><li>As a result, these operations impose a fair amount of overhead on a program, especially if the structure is large.</li>
<li>To avoid this overhead, it is sometimes advisable to pass a structure pointer instead of the structure itself.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="h7dg" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">/*Structures as Argument*/</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">void</span><span class="pln"> print_part</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> part p</span><span class="pun">){</span></code></li><li class="L3"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Part number: %d\n"</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">number</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Part name: %s\n"</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">name</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Quantity on hand: %d\n"</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">.</span><span class="pln">on_hand</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="bc5u" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">/*Structure as Return Value*/</span></code></li><li class="L1"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part build_part</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> number</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> on_hand</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> part p</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="pln">    p</span><span class="pun">.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> number</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">    strcpy</span><span class="pun">(</span><span class="pln">p</span><span class="pun">.</span><span class="pln">name</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">    p</span><span class="pun">.</span><span class="pln">on_hand </span><span class="pun">=</span><span class="pln"> on_hand</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part part1 </span><span class="pun">=</span><span class="pln"> build_part</span><span class="pun">(</span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span></code></li></ol></pre><ul data-anchor-id="7fcf">
<li>Compound Literals <br>
<ul><li>Compound literals were used to create unnamed arrays, usually for the purpose of passing the array to a function.</li>
<li>A compound literal can also be used to create a structure "on the fly", without first storing it in a variable. <br>
<ul><li>The resulting structure can be passed as a parameter, returned by a function, or assigned to a variable.</li>
<li>in general, a compound literal consists of a type name within parentheses, followed by a set of values enclosed by braces.</li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="1jhj" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">print_part</span><span class="pun">((</span><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">){</span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">});</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part part1 </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">){</span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">};</span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="pln">print_part</span><span class="pun">((</span><span class="kwd">struct</span><span class="pln"> part</span><span class="pun">){.</span><span class="pln">on_hand </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="lit">528</span><span class="pun">,</span><span class="pln"> </span><span class="pun">.</span><span class="pln">name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Disk drive"</span><span class="pun">,.</span><span class="pln">number </span><span class="pun">=</span><span class="pln"> </span><span class="lit">528</span><span class="pln"> </span><span class="pun">});</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="jo7r" id="163-nested-arrays-and-structures">16.3 Nested Arrays and Structures</h3><ul data-anchor-id="gkdm">
<li>Nested Structures</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="xzuq" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> person_name</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> first</span><span class="pun">[</span><span class="pln">FIRST_NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> middle_initial1</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> </span><span class="kwd">last</span><span class="pun">[</span><span class="pln">LAST_NAME_LEN </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L4"><code class="language-C"><span class="pun">};</span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="kwd">struct</span><span class="pln"> student </span><span class="pun">{</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> person_name name</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> id</span><span class="pun">,</span><span class="pln"> age</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> sex</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pun">}</span><span class="pln"> student1</span><span class="pun">,</span><span class="pln"> student2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="vojb">
<li>Arrays of Structures</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ccw5" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> part inventory</span><span class="pun">[</span><span class="lit">100</span><span class="pun">];</span></code></li></ol></pre><ul data-anchor-id="p8nb">
<li>Initializing an Array of Structures <br>
<ul><li>In initializing an array of structures, each structure has its own brace-enclosed intializer, and the initializer for the array simply wraps another set of braces around the structre initializers.</li>
<li>One reason for initializing an array of structures is that we are planning to treat it as a database of information that won't change during program execution.</li></ul></li>
</ul><div class="md-section-divider"></div><h3 data-anchor-id="q8es" id="164-unions">16.4 Unions</h3><ul data-anchor-id="hyhl">
<li>Using Unions to Save Space <br>
<ul><li>Definition <br>
<ul><li>A <strong>union</strong> consists of one or more members, possible of different types.</li>
<li>However, the compiler allocates only enough space for the larggest of the members, which overlay each other within this space.</li>
<li>As a result, assigning a new value to one member alters the values of the other members as well.</li></ul></li>
<li>Property <br>
<ul><li>The properties of unions are almost identical to the properties of structures.</li>
<li>Unions can be initialized in a manner similar to structures, but only one member can be initialized whether it's the default initializer or the designated initializer. </li></ul></li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="wbrn" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> catalog_item</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> stock_numer</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">double</span><span class="pln"> price</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> item_type</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">union</span><span class="pun">{</span></code></li><li class="L5"><code class="language-C"><span class="pln">        </span><span class="kwd">struct</span><span class="pun">{</span><span class="kwd">char</span><span class="pln"> title</span><span class="pun">[</span><span class="pln">TITLE_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">char</span><span class="pln"> author</span><span class="pun">[</span><span class="pln">AUTHOR_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L7"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> num_pages</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">book</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L0"><code class="language-C"><span class="pln">        </span><span class="kwd">char</span><span class="pln"> design</span><span class="pun">[</span><span class="pln">DESIGN_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">mug</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L3"><code class="language-C"><span class="pln">        </span><span class="kwd">char</span><span class="pln"> design</span><span class="pun">[</span><span class="pln">DESIGN_LEN</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span></code></li><li class="L4"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> colors</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> sizes</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">shirt</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pun">}</span><span class="pln">item</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="u20z">
<li>Using Unions to Build Mixed Data Structures</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="x053" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">union</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">double</span><span class="pln"> d</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span><span class="typ">Number</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="typ">Number</span><span class="pln"> number_array</span><span class="pun">[</span><span class="lit">1000</span><span class="pun">];</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="pln">number_array</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">number_array</span><span class="pun">[</span><span class="lit">1</span><span class="pun">].</span><span class="pln">d </span><span class="pun">=</span><span class="pln"> </span><span class="lit">8.395</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="6md5">
<li>Adding a "Tag Field" to a Union <br>
<ul><li>There is no easy way to tell which member of a union was last changed and therefore contains a meaningful value.</li>
<li>In order to keep track of this information, we can embed the union within a structure that has one other member: a <strong>tag field</strong> or a <strong>discriminant</strong>, whose purpose is to remind us what's currently stored in the union.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="0rag" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#define</span><span class="pln"> INT_KIND </span><span class="lit">0</span></code></li><li class="L1"><code class="language-C"><span class="com">#define</span><span class="pln"> DOUBLE_KIND </span><span class="lit">1</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> kind</span><span class="pun">;</span><span class="pln">       </span><span class="com">/* tag field */</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="kwd">union</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pln">        </span><span class="kwd">double</span><span class="pln"> d</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln">u</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span><span class="typ">Number</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="typ">Number</span><span class="pln"> n</span><span class="pun">;</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="h7yg" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">n</span><span class="pun">.</span><span class="pln">kind </span><span class="pun">=</span><span class="pln"> INT_KIND</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">n</span><span class="pun">.</span><span class="pln">u</span><span class="pun">.</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">82</span><span class="pun">;</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="sv3y" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">void</span><span class="pln"> print_number</span><span class="pun">(</span><span class="typ">Number</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">n</span><span class="pun">.</span><span class="pln">kind </span><span class="pun">==</span><span class="pln"> INT_KIND</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">.</span><span class="pln">u</span><span class="pun">.</span><span class="pln">i</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="kwd">else</span><span class="pun">{</span></code></li><li class="L4"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln">n</span><span class="pun">.</span><span class="pln">u</span><span class="pun">.</span><span class="pln">d</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="el49" id="165-enumerations">16.5 Enumerations</h3><ul data-anchor-id="0anj">
<li>Definition <br>
<ul><li>A <strong>enumerated type</strong> is a type whose values are listed ("enumerated") by the programmer, who must create a name (an <strong>enumeration constant</strong>) for each of the values.</li>
<li>The names of enumeration constants must be different from other identifiers declared in the enclosing scope.</li>
<li>Enumeration constants are subject to C's scope rules: if an enumeration is declared inside a function, its constants won't be visible outside the function.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="q06f" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    CLUBS</span><span class="pun">,</span></code></li><li class="L2"><code class="language-C"><span class="pln">    DIAMONDS</span><span class="pun">,</span></code></li><li class="L3"><code class="language-C"><span class="pln">    HEARTS</span><span class="pun">,</span></code></li><li class="L4"><code class="language-C"><span class="pln">    SPADE</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span><span class="pln">s1</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="sn3i">
<li>Enumeration Tags and Type Names <br>
<ul><li>ther are two ways to name an enumeration: by declaring a tag or by using typedef to create a genuine type name.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="01yy" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> suit </span><span class="pun">{</span><span class="pln">CLUBS</span><span class="pun">,</span><span class="pln"> DIAMONDS</span><span class="pun">,</span><span class="pln"> HEARTS</span><span class="pun">,</span><span class="pln"> SPADES</span><span class="pun">};</span></code></li><li class="L1"><code class="language-C"><span class="kwd">enum</span><span class="pln"> suit s1</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">;</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="9nk7" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">enum</span><span class="pln"> </span><span class="pun">{</span><span class="pln">CLUBS</span><span class="pun">,</span><span class="pln"> DIAMONDS</span><span class="pun">,</span><span class="pln"> HEARTS</span><span class="pun">,</span><span class="pln"> SPADES</span><span class="pun">}</span><span class="pln"> </span><span class="typ">Suit</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="typ">Suit</span><span class="pln"> s1</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="6dba">
<li>Enumerations as Inegers <br>
<ul><li>C actually treats enumeration variables and constants as integers, and by default the compiler assigns the integers 0,1,2, ... to the constants in a particular enumeration. <br>
<ul><li>But we are free to choose different values for enumeration constants if we like.</li>
<li>It's even legal for two or more enumeration oncstants to have the same value.</li></ul></li>
<li>When no value is specified for an enumeration constant, its value is one greater than the value of the previous constant. (The first enumeration constant has the value 0 by defaut.)</li>
<li>Since enumeration values are nothing by thinly disguised integers, C allows us to mix them with ordinary integers(but is dangerous)</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="pjdq" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> suit </span><span class="pun">{</span><span class="pln">CLUBS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> DIAMONDS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> HEARTS </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> SPADES </span><span class="pun">=</span><span class="pln"> </span><span class="lit">4</span><span class="pun">};</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="pln">i </span><span class="pun">=</span><span class="pln"> DIAMONDS</span><span class="pun">;</span></code></li><li class="L3"><code class="language-C"><span class="pln">s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">s</span><span class="pun">++;</span></code></li><li class="L5"><code class="language-C"><span class="pln">i </span><span class="pun">=</span><span class="pln"> s </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="7x7l">
<li>Using Enumerations to Declare Tag Fields</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="8flr" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">typedef</span><span class="pln"> </span><span class="kwd">struct</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">enum</span><span class="pln"> </span><span class="pun">{</span><span class="pln">INT_KIND</span><span class="pun">,</span><span class="pln"> DOUBLE_KIND</span><span class="pun">}</span><span class="pln"> kind</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">union</span><span class="pun">{</span></code></li><li class="L3"><code class="language-C"><span class="pln">        </span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">        </span><span class="kwd">double</span><span class="pln"> d</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="pln"> u</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span><span class="typ">Number</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="udqk">
<li>Use the Values of an Enumerated Type as Subscripts</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="oogf" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">enum</span><span class="pln"> weekdays </span><span class="pun">{</span><span class="pln">MONDAY</span><span class="pun">,</span><span class="pln"> TUESDAY</span><span class="pun">,</span><span class="pln"> WEDNESDAY</span><span class="pun">,</span><span class="pln"> THURSDAY</span><span class="pun">,</span><span class="pln"> FRIDAY</span><span class="pun">};</span></code></li><li class="L1"><code class="language-C"><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">daily_specials</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">MONDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="str">"beef ravioli"</span><span class="pun">,</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">TUESDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"BLTs"</span><span class="pun">,</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">WEDNESDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Pizza"</span><span class="pun">,</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">THURSDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Chicken fajitas"</span><span class="pun">,</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="pun">[</span><span class="pln">FRIDAY</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Macaroni and cheese"</span></code></li><li class="L7"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="lsnd" id="17-advanced-uses-of-pointers">17. Advanced Uses of Pointers</h2><div class="md-section-divider"></div><h3 data-anchor-id="nl4r" id="171-dynamic-storage-allocation">17.1 Dynamic Storage Allocation</h3><ul data-anchor-id="9o6r">
<li>Memory Allocation Functions <br>
<ul><li><strong>Dynamic storage allocation</strong> refers to the ability to allocate storage during program execution. <br>
<ul><li>Using dynamic storage allocation, we can design data structures that grow and shrink as needed.</li></ul></li>
<li>Functions <br>
<ul><li><code>malloc</code> - Allocates a block of memory but doesn't initialize it.</li>
<li><code>calloc</code> - Allocates a block of memory and clears it.</li>
<li><code>realloc</code> - Resizes a previously allocated block of memory.</li></ul></li>
<li>void type <br>
<ul><li>When we call a memory allocation function to request a block of memory, the function doesn't know what type of data we are planning to store in the block, so it returns a value of type <code>void *</code>.</li>
<li>A <code>void *</code> value is a generic pointer - essentially, just a memory address.</li></ul></li></ul></li>
<li>Null Pointers <br>
<ul><li>When a memory allocation function can't locate a block of memory large enough to satisfy our request, the function will return a <strong>null pointer</strong>, represented by a macro named NULL.</li>
<li>In C, pointers test true or false in the ame way as numbers. All non-null pointers test true; only null pointers are false.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="ubdb" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">//use example 1</span></code></li><li class="L1"><code class="language-C"><span class="kwd">if</span><span class="pun">(</span><span class="pln">p </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="lit">10000</span><span class="pun">)</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="com">/*Allocateion failed; take appropriate action*/</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="nltb" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">if</span><span class="pun">(</span><span class="pln">p </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">)...</span></code></li><li class="L1"><code class="language-C"><span class="kwd">if</span><span class="pun">(!</span><span class="pln">p</span><span class="pun">)</span><span class="pln"> </span><span class="pun">...</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="kvng" id="172-dynamically-allocated-strings">17.2 Dynamically Allocated Strings</h3><ul data-anchor-id="hpq9">
<li>Using <code>malloc</code> to Allocate Memory for a String <br>
<ul><li>Functionality <br>
<ul><li>Prototype: <code>void *malloc(size_t size);</code></li>
<li>malloc allocates a block of <code>size</code> bytes and return a pointer to it.  <br>
<ul><li><code>size</code> has type <code>size_t</code>, an unsigned integer type defined in the C library.</li>
<li>In c, a char value requires exactly one byte of stoage - <code>sizeof(char)</code> is 1.</li></ul></li></ul></li>
<li>Example</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="kf4k" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*)</span><span class="pln"> malloc </span><span class="pun">(</span><span class="pln">n</span><span class="pun">+</span><span class="lit">1</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pln">strcpy</span><span class="pun">(</span><span class="pln">p</span><span class="pun">,</span><span class="pln"> </span><span class="str">"abc"</span><span class="pun">);</span></code></li><li class="L2"><code class="language-C"><span class="com">//the first four characters in the array will now be a, b, c, and \0</span></code></li></ol></pre><ul data-anchor-id="o46u">
<li>Using Dynamic Storage Allocation in String Functions</li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="rwac" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">concat </span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">s2</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">*</span><span class="pln">result</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    result </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">s1</span><span class="pun">)+</span><span class="pln">strlen</span><span class="pun">(</span><span class="pln">s2</span><span class="pun">)+</span><span class="lit">1</span><span class="pun">);</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">result </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"Error: malloc failed in concat\n"</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">exit</span><span class="pun">(</span><span class="pln">EXIT_FAILURE</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C"><span class="pln">    strcpy</span><span class="pun">(</span><span class="pln">result</span><span class="pun">,</span><span class="pln"> s1</span><span class="pun">);</span></code></li><li class="L9"><code class="language-C"><span class="pln">    strcat</span><span class="pun">(</span><span class="pln">result</span><span class="pun">,</span><span class="pln"> s2</span><span class="pun">);</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li></ol></pre><div class="md-section-divider"></div><h3 data-anchor-id="hjhx" id="173-dynamically-alloated-arrays">17.3 Dynamically Alloated Arrays</h3><ul data-anchor-id="leal">
<li>Using <code>malloc</code> to Allocate Storage for an Array <br>
<ul><li>The primary difference in the allocation of storage for an array from that of a string is that the elements of an arbitrary array won't necessarily be one byte long, so we need to use the <code>sizeof()</code> operator to calcuclate the amount of space required.</li>
<li>Once the variable points to a dynamically allocated block of memory, we can ignore the fact that that variable is a pointer and use it instead as an array name.</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="clef" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">int</span><span class="pln"> </span><span class="pun">*</span><span class="pln">a</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">a </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="pln">n</span><span class="pun">*</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">));</span></code></li><li class="L2"><code class="language-C"><span class="pln">a</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li></ol></pre><ul data-anchor-id="kcxw">
<li>The <code>calloc</code> Function <br>
<ul><li>Functionality <br>
<ul><li>Prototype: <code>void *calloc(size_t nmemb, size_t size);</code></li>
<li><code>calloc</code> allocates space for an array with <code>nmemb</code> elements, each of which is <code>size</code> bytes long;</li>
<li>It returns a null pointer if the requested space isn't available.</li>
<li>After allocating the memory, <code>calloc</code> initializes it by setting all bits to 0.</li></ul></li>
<li>Example</li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="jvn7" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> point </span><span class="pun">{</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">,</span><span class="pln"> y</span><span class="pun">;}</span><span class="pln"> </span><span class="pun">*</span><span class="pln">p</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">p </span><span class="pun">=</span><span class="pln"> calloc</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> point</span><span class="pun">));</span></code></li></ol></pre><ul data-anchor-id="ooz9">
<li>The <code>realloc</code> Function <br>
<ul><li>The <code>realloc</code> function can resize the array to better suit our needs.</li>
<li>Function <br>
<ul><li>Prototype: <code>void *realloc(void *ptr, size)&lt;/li&gt; <br>
&lt;li&gt;Rules <br>
&lt;ul&gt;&lt;li&gt;When it expands a memory block,</code>realloc<code>doesn't initialize the bytes that are added to the block.&lt;/li&gt; <br>
&lt;li&gt;If</code>realloc<code>can't enlarge the memory block as requested, it returns a null pointer; the data in the old memory block is unchanged.&lt;/li&gt; <br>
&lt;li&gt;If</code>realloc<code>is called with 0 as its second argument, it frees the memory block.&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt; <br>
&lt;li&gt;Once</code>realloc<code>has returned, be sure to update all pointers to the memory block, since it's possible that</code>realloc` has moved the block elsewhere.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="174-deallocating-storage">17.4 Deallocating Storage</h3>

<ul>
<li>Definitions <br>
<ul><li>A block of memory that's no longer accessible to a program is said to be <strong>garbage</strong>.</li>
<li>A program that leaves garbage behind has a <strong>memory leak</strong>.</li>
<li>Each C program is responsible for recycling its own garbage by calling the <code>free</code> function to release unneeded memory.</li></ul></li>
<li>The <code>free</code> Function <br>
<ul><li>Prototype: <code>void free(void *ptr);</code></li>
<li>callign <code>free</code> releases the block of memory that <code>p</code> points to, so this will be available for reuse in subsequent calls of malloc or other memory allocation functions.</li></ul></li>
<li>The "Dangling Pointer" Problem <br>
<ul><li>The <strong>dangling pointer</strong> problem refers to the fact that the call <code>free(p)</code> deallocates the memory block that p points to, but doesn't change p itself.</li>
<li>If we forget that p no longer points to a valid memory block, chaos may ensue.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="175-linked-lists">17.5 Linked Lists</h3>

<ul>
<li>Introduction <br>
<ul><li>A <strong>linked list</strong> consists of a chain of structures (called <strong>nodes</strong>), with each node containing a pointer to the next node in the chain.</li>
<li>The last node in the list contains a null pointer.</li></ul></li>
<li>Declaring a Node Type <br>
<ul><li>In the definition of node (below), we used <code>struct node</code>. <br>
<ul><li>This is because when a structure has a member that points to the same kind of structure, we are required to use a structure.</li></ul></li>
<li>After declaring a node, we always need a pointer for the first node in the linked list.</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> value</span><span class="pun">;</span><span class="pln">          </span><span class="com">/* data stored in the node */</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="kwd">next</span><span class="pun">;</span><span class="pln">  </span><span class="com">/* pointer to the next node */</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">first </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li></ol></pre>

<ul>
<li>Creating a Node <br>
<ul><li>Three Steps <br>
<ul><li>Allocate memory for the node</li>
<li>Store data in the node</li>
<li>Insert the node into the list</li></ul></li>
<li>Codes</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">new_node </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">));</span><span class="pln"> </span><span class="com">// allocate memory</span></code></li><li class="L1"><code class="language-C"><span class="pun">(*</span><span class="pln"> new_node</span><span class="pun">).</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span><span class="pln"> </span><span class="com">//store data</span></code></li><li class="L2"><code class="language-C"><span class="com">//or</span></code></li><li class="L3"><code class="language-C"><span class="pln">new_node</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span></code></li></ol></pre>

<ul>
<li>Inserting a Node at the Beginning of a Linked List</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="pln">new_node</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> first</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pln">first </span><span class="pun">=</span><span class="pln"> new_node</span><span class="pun">;</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">add_to_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">new_node</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    new_node </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node</span><span class="pun">));</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">new_node </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"Error: malloc failed in add_to_list\n"</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="kwd">exit</span><span class="pun">(</span><span class="pln">EXIT_FAILURE</span><span class="pun">);</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C"><span class="pln">    new_node</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pln">    new_node</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> new_node</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"><span class="pun">}</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="com">//to use the method</span></code></li><li class="L5"><code class="language-C"><span class="pln">first </span><span class="pun">=</span><span class="pln"> add_to_list</span><span class="pun">(</span><span class="pln">first</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="com">//to create linked list</span></code></li><li class="L8"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">read_numbers</span><span class="pun">(</span><span class="kwd">void</span><span class="pun">){</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">first </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L0"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span></code></li><li class="L1"><code class="language-C"></code></li><li class="L2"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Enter a series of integers (0 to terminate): "</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(;;){</span></code></li><li class="L4"><code class="language-C"><span class="pln">        scanf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,&amp;</span><span class="pln">n</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n</span><span class="pun">==</span><span class="lit">0</span><span class="pun">)</span></code></li><li class="L6"><code class="language-C"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> first</span><span class="pun">;</span></code></li><li class="L7"><code class="language-C"><span class="pln">        first </span><span class="pun">=</span><span class="pln"> add_to_list</span><span class="pun">(</span><span class="pln">first</span><span class="pun">,</span><span class="pln">n</span><span class="pun">);</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Searching a Linked List</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">search_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">p</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">p </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">;</span><span class="pln"> p </span><span class="pun">!=</span><span class="pln"> NULL</span><span class="pun">;</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">){</span></code></li><li class="L4"><code class="language-C"><span class="pln">        </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">p</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L5"><code class="language-C"><span class="pln">            </span><span class="kwd">return</span><span class="pln"> p</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pln">        </span><span class="pun">}</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="com">//or</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">search_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(;</span><span class="pln">list </span><span class="pun">!=</span><span class="pln">NULL </span><span class="pun">&amp;&amp;</span><span class="pln"> list </span><span class="pun">-&gt;</span><span class="pln">value</span><span class="pun">!=</span><span class="pln">n</span><span class="pun">;</span><span class="pln">list</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">);</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> list</span><span class="pun">;</span></code></li><li class="L6"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Deleting a Node from a Linked List <br>
<ul><li>Three Steps <br>
<ul><li>Locate the node to be deleted.</li>
<li>Alter the previous node so that it "bypasses" the deleted node.</li>
<li>Call <code>free</code> to reclaim the space occupied by the deleted node.</li></ul></li>
<li>Code</li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">delete_from_list</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">list</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">){</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">struct</span><span class="pln"> node </span><span class="pun">*</span><span class="pln">cur</span><span class="pun">,</span><span class="pln"> </span><span class="pun">*</span><span class="pln">prev</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">cur </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">,</span><span class="pln"> prev </span><span class="pun">=</span><span class="pln"> NULL</span><span class="pun">;</span></code></li><li class="L4"><code class="language-C"><span class="pln">        cur </span><span class="pun">!=</span><span class="pln"> NULL </span><span class="pun">&amp;&amp;</span><span class="pln"> cur</span><span class="pun">-&gt;</span><span class="pln">value </span><span class="pun">!=</span><span class="pln">n</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pln">        prev </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">,</span><span class="pln"> cur </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">-&gt;</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">);</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">cur </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L8"><code class="language-C"><span class="pln">        retun list</span><span class="pun">;</span><span class="pln">         </span><span class="com">// n was not found</span></code></li><li class="L9"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">prev </span><span class="pun">==</span><span class="pln"> NULL</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        list </span><span class="pun">=</span><span class="pln"> list</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span><span class="pln">  </span><span class="com">// n is in the first node</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span><span class="kwd">else</span><span class="pun">{</span></code></li><li class="L4"><code class="language-C"><span class="pln">        prev</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cur</span><span class="pun">-&gt;</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"> </span><span class="com">// n is in some other node</span></code></li><li class="L5"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L6"><code class="language-C"></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> list</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<h3 id="176-pointers-to-pointers">17.6 Pointers to Pointers</h3>

<ul>
<li>A pointer to a pointer is a form of multiple indirection, or a chain of pointers. </li>
<li>Normally, a pointer contains the address of a variable.  <br>
<ul><li>When we define a pointer to a pointer, the first pointer contains the address of the second pointer, which points to the location that contains the actual value as shown below.</li>
<li><img src="https://www.tutorialspoint.com/cprogramming/images/pointer_to_pointer.jpg" alt="pointers to pointers" title=""></li></ul></li>
<li><code>int **var;</code></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="177-pointers-to-functions">17.7 Pointers to Functions</h3>

<ul>
<li>Introduction <br>
<ul><li>Definition <br>
<ul><li>In C, like normal data pointers (int *, char *, etc), we can have pointers to functions. </li></ul></li>
<li>Rules <br>
<ul><li>Unlike normal pointers, a function pointer points to code, not data. Typically a function pointer stores the start of executable code.</li>
<li>Unlike normal pointers, we do not allocate de-allocate memory using function pointers.</li>
<li>A function’s name can also be used to get functions’ address. (so we can emit the address operator)</li>
<li>Like normal pointers, we can have an array of function pointers</li></ul></li></ul></li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="com">#include</span><span class="pln"> </span><span class="str">&lt;stdio.h&gt;</span><span class="pln"> </span></code></li><li class="L1"><code class="language-C"><span class="kwd">void</span><span class="pln"> add</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L2"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L3"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Addition is %d\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">+</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L4"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li><li class="L5"><code class="language-C"><span class="kwd">void</span><span class="pln"> subtract</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L6"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L7"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Subtraction is %d\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">-</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L8"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li><li class="L9"><code class="language-C"><span class="kwd">void</span><span class="pln"> multiply</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span></code></li><li class="L0"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L1"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Multiplication is %d\n"</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">*</span><span class="pln">b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L2"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span></code></li><li class="L5"><code class="language-C"><span class="pun">{</span><span class="pln"> </span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="com">// fun_ptr_arr is an array of function pointers </span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">fun_ptr_arr</span><span class="pun">[])(</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">add</span><span class="pun">,</span><span class="pln"> subtract</span><span class="pun">,</span><span class="pln"> multiply</span><span class="pun">};</span><span class="pln"> </span></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">unsigned</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> ch</span><span class="pun">,</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">15</span><span class="pun">,</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="pln">    printf</span><span class="pun">(</span><span class="str">"Enter Choice: 0 for add, 1 for subtract and 2 "</span></code></li><li class="L1"><code class="language-C"><span class="pln">            </span><span class="str">"for multiply\n"</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L2"><code class="language-C"><span class="pln">    scanf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">ch</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L3"><code class="language-C"></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ch </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L5"><code class="language-C"></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="pun">(*</span><span class="pln">fun_ptr_arr</span><span class="pun">[</span><span class="pln">ch</span><span class="pun">])(</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">);</span><span class="pln"> </span></code></li><li class="L7"><code class="language-C"></code></li><li class="L8"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> </span></code></li><li class="L9"><code class="language-C"><span class="pun">}</span><span class="pln"> </span></code></li></ol></pre>

<ul>
<li>The <code>qsort</code> Function</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="kwd">int</span><span class="pln"> compare</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> </span><span class="pun">*</span><span class="pln">b</span><span class="pun">){</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">(*(</span><span class="kwd">int</span><span class="pln"> </span><span class="pun">*)</span><span class="pln">a </span><span class="pun">-</span><span class="pln"> </span><span class="pun">*(</span><span class="kwd">int</span><span class="pun">*)</span><span class="pln">b</span><span class="pun">);</span></code></li><li class="L3"><code class="language-C"><span class="pun">}</span></code></li><li class="L4"><code class="language-C"></code></li><li class="L5"><code class="language-C"><span class="kwd">int</span><span class="pln"> main</span><span class="pun">(){</span></code></li><li class="L6"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> arr</span><span class="pun">[]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="lit">10</span><span class="pun">,</span><span class="lit">5</span><span class="pun">,</span><span class="lit">15</span><span class="pun">,</span><span class="lit">12</span><span class="pun">,</span><span class="lit">90</span><span class="pun">,</span><span class="lit">80</span><span class="pun">};</span></code></li><li class="L7"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> n </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">)/</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> i</span><span class="pun">;</span></code></li><li class="L8"><code class="language-C"></code></li><li class="L9"><code class="language-C"><span class="pln">    qsort</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">,</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">int</span><span class="pun">),</span><span class="pln"> compare</span><span class="pun">);</span></code></li><li class="L0"><code class="language-C"></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">for</span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln">i</span><span class="pun">++){</span></code></li><li class="L2"><code class="language-C"><span class="pln">        printf</span><span class="pun">(</span><span class="str">"%d"</span><span class="pun">,</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]);</span></code></li><li class="L3"><code class="language-C"><span class="pln">    </span><span class="pun">}</span></code></li><li class="L4"><code class="language-C"><span class="pln">    </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span></code></li><li class="L5"><code class="language-C"><span class="pun">}</span></code></li></ol></pre>

<ul>
<li>Other Uses of Function Pointers</li>
</ul>

<div class="md-section-divider"></div>

<pre class="prettyprint linenums prettyprinted" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">void</span><span class="pln"> </span><span class="pun">(*</span><span class="pln">file_cmd</span><span class="pun">[])(</span><span class="kwd">void</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">new_cmd</span><span class="pun">,</span></code></li><li class="L1"><code class="language-C"><span class="pln">                            open_cmd</span><span class="pun">,</span></code></li><li class="L2"><code class="language-C"><span class="pln">                            close_cmd</span><span class="pun">,</span></code></li><li class="L3"><code class="language-C"><span class="pln">                            close_all_cmd</span><span class="pun">};</span></code></li></ol></pre>

<div class="md-section-divider"></div>

<h3 id="178-restricted-pointers">17.8 Restricted Pointers</h3>

<ul>
<li>Code <br>
<ul><li><code>int * restrict p;</code></li></ul></li>
<li>Definition <br>
<ul><li>a pointer that's been declared using <code>restrict</code> is called a <strong>restected pointer</strong></li>
<li>The intent is that if p points to an object that is later modified, then that object is not accessed in any way other than through p.</li></ul></li>
<li>Advantage <br>
<ul><li>restrict provides information to the compiler that may enable it to produce more efficient code - a process known as optimization. </li></ul></li>
</ul>

<div class="md-section-divider"></div>

<h3 id="179-flexible-array-members">17.9 Flexible Array Members</h3>

<ul>
<li>We can store the length of the string with the string's characters (but with no null character).</li>
<li>A structure that contains a 1lexible array member is an <strong>incomplete type</strong>.  <br>
</li><li>An incomplete type is missing pan of the information needed to determine how much <br>
memory it requires. </li></ul></li>
</ul><div class="md-section-divider"></div><pre class="prettyprint linenums prettyprinted" data-anchor-id="d1am" style=""><ol class="linenums"><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> vstring</span><span class="pun">{</span></code></li><li class="L1"><code class="language-C"><span class="pln">    </span><span class="kwd">int</span><span class="pln"> len</span><span class="pun">;</span></code></li><li class="L2"><code class="language-C"><span class="pln">    </span><span class="kwd">char</span><span class="pln"> chars</span><span class="pun">[</span><span class="lit">1</span></code></li><li class="L3"><code class="language-C"><span class="pln">    A structure that contains a </span><span class="lit">1lexible</span><span class="pln"> array member </span><span class="kwd">is</span><span class="pln"> an incomplete type</span><span class="pun">.</span><span class="pln"> </span><span class="typ">An</span></code></li><li class="L4"><code class="language-C"><span class="pln">incomplete type </span><span class="kwd">is</span><span class="pln"> missing pan of the information needed to determine how much</span></code></li><li class="L5"><code class="language-C"><span class="pln">memory it requires</span><span class="pun">.</span><span class="pln"> </span><span class="pun">];</span></code></li><li class="L6"><code class="language-C"><span class="pun">};</span></code></li><li class="L7"><code class="language-C"><span class="com">//The length of the char array isn't determined </span></code></li><li class="L8"><code class="language-C"><span class="com">//until memory is allocated for a vstring structure.</span></code></li><li class="L9"><code class="language-C"></code></li><li class="L0"><code class="language-C"><span class="kwd">struct</span><span class="pln"> vstring </span><span class="pun">*</span><span class="pln">str </span><span class="pun">=</span><span class="pln"> malloc</span><span class="pun">(</span><span class="kwd">sizeof</span><span class="pun">(</span><span class="kwd">struct</span><span class="pln"> vstring</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> n</span><span class="pun">);</span></code></li><li class="L1"><code class="language-C"><span class="pln">str</span><span class="pun">-&gt;</span><span class="pln">len </span><span class="pun">=</span><span class="pln"> n</span><span class="pun">;</span></code></li></ol></pre><hr><div class="md-section-divider"></div><h2 data-anchor-id="x4p5" id="18-declarations">18. Declarations</h2><div class="md-section-divider"></div><h2 data-anchor-id="291s" id="19-program-design">19. Program Design</h2><div class="md-section-divider"></div><h2 data-anchor-id="mvis" id="20-low-level-programming">20. Low-Level Programming</h2><div class="md-section-divider"></div><h2 data-anchor-id="ew6u" id="21-the-standard-library">21. The Standard Library</h2><div class="md-section-divider"></div><h2 data-anchor-id="m8uk" id="22-inputoutput">22. Input/Output</h2><div class="md-section-divider"></div><h2 data-anchor-id="vi7u" id="23-library-support-for-numbers-and-character-data">23. Library Support for Numbers and Character Data</h2><div class="md-section-divider"></div><h2 data-anchor-id="8iy0" id="24-error-handling">24. Error Handling</h2><div class="md-section-divider"></div><h2 data-anchor-id="awo7" id="25-international-features">25. International Features</h2><div class="md-section-divider"></div><h2 data-anchor-id="bczd" id="26-miscellaneous-library-functions">26. Miscellaneous Library Functions</h2><div class="md-section-divider"></div><h2 data-anchor-id="ysse" id="27-additional-c99-support-for-mathematics">27. Additional C99 Support for Mathematics</h2></div>
</body>
</html>